<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="PHP,Laravel,thinkPHP,javascript,css">
<meta property="og:type" content="website">
<meta property="og:title" content="slpi1">
<meta property="og:url" content="http://blog.slpi1.com/page/2/index.html">
<meta property="og:site_name" content="slpi1">
<meta property="og:description" content="PHP,Laravel,thinkPHP,javascript,css">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="slpi1">
<meta name="twitter:description" content="PHP,Laravel,thinkPHP,javascript,css">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.slpi1.com/page/2/"/>





  <title>slpi1</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">slpi1</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">slpi1</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20191101/discuss/error.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20191101/discuss/error.html" itemprop="url">错误与异常的处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-01T17:15:00+08:00">
                2019-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><ul>
<li><a href="#概念">概念</a><ul>
<li><a href="#什么是异常">什么是异常</a><ul>
<li><a href="#异常的捕获">异常的捕获</a></li>
<li><a href="#异常未捕获的情况">异常未捕获的情况</a></li>
</ul>
</li>
<li><a href="#什么是错误">什么是错误</a><ul>
<li><a href="#错误级别">错误级别</a></li>
<li><a href="#错误的捕获">错误的捕获</a></li>
<li><a href="#错误未捕获的情况">错误未捕获的情况</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#模拟错误的产生">模拟错误的产生</a><ul>
<li><a href="#E_NOTICE">E_NOTICE</a></li>
<li><a href="#E_WARNING">E_WARNING</a></li>
<li><a href="#E_ERROR">E_ERROR</a></li>
</ul>
</li>
<li><a href="#异常的运用">异常的运用</a><ul>
<li><a href="#前提">前提</a></li>
<li><a href="#使用">使用</a></li>
</ul>
</li>
</ul>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>首先要注意区分错误与异常的概念。</p>
<h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>所有的异常都由一个基类：Exception。异常是指在代码中由程序猿通过 <code>throw new Exception</code> 语法主动抛出的。</p>
<h3 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h3><p>异常可以通过两种方式进行捕获：</p>
<ul>
<li><code>try/catch</code> 语句块进行捕获</li>
<li><code>set_exception_handler</code> 异常处理函数</li>
</ul>
<blockquote>
<p>Exception 异常可以被第一个匹配的 try / catch 块所捕获。如果没有匹配的 catch 块，则调用异常处理函数（事先通过 set_exception_handler() 注册）进行处理。</p>
</blockquote>
<h3 id="异常未捕获的情况"><a href="#异常未捕获的情况" class="headerlink" title="异常未捕获的情况"></a>异常未捕获的情况</h3><p>如果没有对异常进行捕获，就会产生一个致命错误。</p>
<blockquote>
<p>如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误（Fatal Error）。</p>
</blockquote>
<h2 id="什么是错误"><a href="#什么是错误" class="headerlink" title="什么是错误"></a>什么是错误</h2><p>错误是代码在运行过程中产生的，一般不由程序猿主动抛出。当出现错误时，说明代码中有bug，需要进行修复。</p>
<h3 id="错误级别"><a href="#错误级别" class="headerlink" title="错误级别"></a>错误级别</h3><p>错误有级别之分。经常遇到的错误级别有下列几种:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>E_ERROR</td>
<td>致命的运行时错误。这类错误一般是不可恢复的情况，例如内存分配导致的问题。后果是导致脚本终止不再继续运行。</td>
</tr>
<tr>
<td>2</td>
<td>E_WARNING</td>
<td>运行时警告 (非致命错误)。仅给出提示信息，但是脚本不会终止运行。</td>
</tr>
<tr>
<td>8</td>
<td>E_NOTICE</td>
<td>运行时通知。表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知。</td>
</tr>
</tbody>
</table>
<p>其他的错误类型在日常开发中可能遇到的不是很多，就不进行一一列举。其中, <code>E_ERROR</code> 类型的错误分为可捕获错误与致命错误。</p>
<h3 id="错误的捕获"><a href="#错误的捕获" class="headerlink" title="错误的捕获"></a>错误的捕获</h3><p>错误也是可进行捕获的。在PHP7中，由于改变了大多数错误的报告方式，大多数错误被作为 Error 异常抛出，也可以通过  try / catch 块进行捕获。</p>
<ul>
<li><code>try/catch</code> 语句块进行捕获</li>
<li><code>set_exception_handler</code> 异常处理函数</li>
<li><code>set_error_handler</code> 错误处理函数</li>
<li><code>register_shutdown_function =&gt; error_get_last</code></li>
</ul>
<p>set_error_handler 错误处理函数所能捕获的错误有限。</p>
<blockquote>
<p>以下级别的错误不能由用户定义的函数来处理： E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，和在 调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT。</p>
</blockquote>
<p>register_shutdown_function 会由以下情况触发：</p>
<ul>
<li>脚本正常退出时</li>
<li>在脚本运行(run-time not parse-time)出错退出时</li>
<li>用户调用exit方法退出时</li>
</ul>
<p>也就是说 register_shutdown_function 被执行时，并不能捕获到错误，需要在函数体内，由error_get_last来捕获最后产生的错误。</p>
<p>按错误级别由低到高来分的话，上述捕获手段可以分别捕获到如下表所示的错误：</p>
<table>
<thead>
<tr>
<th>错误级别</th>
<th>备注</th>
<th>捕获手段</th>
</tr>
</thead>
<tbody>
<tr>
<td>8/E_NOTICE</td>
<td></td>
<td>set_error_handler/register_shutdown_function</td>
</tr>
<tr>
<td>2/E_WARNING</td>
<td></td>
<td>set_error_handler/register_shutdown_function</td>
</tr>
<tr>
<td>1/E_ERROR</td>
<td>可捕获错误</td>
<td>try/set_exception_handler/register_shutdown_function</td>
</tr>
<tr>
<td>1/E_ERROR</td>
<td>致命错误</td>
<td>register_shutdown_function</td>
</tr>
</tbody>
</table>
<h3 id="错误未捕获的情况"><a href="#错误未捕获的情况" class="headerlink" title="错误未捕获的情况"></a>错误未捕获的情况</h3><p>程序bug。</p>
<p>综上所述，如果在抛出一个异常之后：</p>
<ul>
<li>没有 try / catch , set_exception_handler 进行捕获，会报告为一个错误</li>
<li>没有 set_error_handler 进行错误的捕获（其实 set_error_handler 也无法捕获上述错误）</li>
<li>没有 register_shutdown_function、error_get_last 进行捕获<br>则程序会中断运行。</li>
</ul>
<h1 id="模拟错误的产生"><a href="#模拟错误的产生" class="headerlink" title="模拟错误的产生"></a>模拟错误的产生</h1><p>错误的模拟主要是为了方便验证上述捕获手段，并不会在实际中进行运用，关于错误模拟可以参考文件夹<a href="./error">error</a>部分的代码</p>
<h2 id="E-NOTICE"><a href="#E-NOTICE" class="headerlink" title="E_NOTICE"></a>E_NOTICE</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$test未定义，会报一个notice级别的错误</span></span><br><span class="line"><span class="keyword">return</span> $a;</span><br></pre></td></tr></table></figure>
<h2 id="E-WARNING"><a href="#E-WARNING" class="headerlink" title="E_WARNING"></a>E_WARNING</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$array = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// in_array函数需要传入两个参数，会报一个warning级别的错误</span></span><br><span class="line">in_array($array);</span><br></pre></td></tr></table></figure>
<h2 id="E-ERROR"><a href="#E-ERROR" class="headerlink" title="E_ERROR"></a>E_ERROR</h2><p>可捕获错误：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(Array $array)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum指定传入一个数组参数，会报一个TypeError的可捕获错误</span></span><br><span class="line">sum(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure></p>
<p>致命错误:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果这里test的定义不放在if中，会在编译阶段报告语法错误，而不会进入到运行时。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="异常的运用"><a href="#异常的运用" class="headerlink" title="异常的运用"></a>异常的运用</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>在运用异常之前，务必先了解框架的异常处理机制，或者自行设计异常的处理机制。laravel框架的异常处理逻辑主要在 <code>Illuminate\Foundation\Bootstrap\HandleExceptions::class</code> 这个类中。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>异常的使用，是指通过异常捕获机制，根据捕获到的不同类型的异常，来决定作出什么样的处理。我在项目中比较常用的技巧，是通过异常来决定接口的响应，在异常捕获的逻辑中有以下两个逻辑分支:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($exception <span class="keyword">instanceof</span> ErrorLogicException) &#123;</span><br><span class="line">    <span class="comment">// 逻辑错误，需要反馈给用户阅读，并翻译为用户当前语系</span></span><br><span class="line">    <span class="keyword">return</span> response()-&gt;json([</span><br><span class="line">        <span class="string">'code'</span> =&gt; $exception-&gt;getCode(),</span><br><span class="line">        <span class="string">'data'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        <span class="string">'msg'</span>  =&gt; $exception-&gt;getMessage(),</span><br><span class="line">    ]);</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($exception <span class="keyword">instanceof</span> ErrorDebugException) &#123;</span><br><span class="line">    <span class="comment">// debug 错误，给用户返回一个统一的信息</span></span><br><span class="line">    <span class="comment">// 日志记录错误信息，debug模式下直接返回错误信息，用于调试</span></span><br><span class="line">    $info = $exception-&gt;getMessage();</span><br><span class="line">    Log::debug($info);</span><br><span class="line">    <span class="keyword">return</span> response()-&gt;json([</span><br><span class="line">        <span class="string">'code'</span> =&gt; $exception-&gt;getCode(),</span><br><span class="line">        <span class="string">'data'</span> =&gt; <span class="string">''</span>,</span><br><span class="line">        <span class="string">'msg'</span>  =&gt; config(<span class="string">'app.debug'</span>) ? $info : __(<span class="string">'common.failed'</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先定义两种异常类型:</p>
<ul>
<li>ErrorLogicException: 流程逻辑错误。指没有按照规定使用，产生的异常类型。这个时候会返回明确的错误提示，或者指导用户什么是正确的操作。</li>
<li>ErrorDebugException: 非正常错误，泛指不可预知的错误，但是会影响流程的正确性。这个时候并不需要告知用户发生了什么错误，但是需要记录错误发生的相关信息，交由开发者进一步分析问题产生的原因。比如：数据保存失败等小概率事件。</li>
</ul>
<p>然后在需要的地方抛出对应的异常即可。</p>
<p>对于ErrorLogicException异常的情形，并非一定要按上述逻辑来处理，因为在抛出ErrorLogicException异常的情形下，都是确定出错了的情况，也可以通过 <code>return false</code> 来返回函数的调用栈，如果代码的层级比较深，可能要经过<code>Model -&gt; Service -&gt; Controller</code> 或更多的层级来return到Controller，这个时候用异常就会有“短路”的效果，避免过多层级的return。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20191025/discuss/config.draft.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20191025/discuss/config.draft.html" itemprop="url">可配置化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-25T16:41:00+08:00">
                2019-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>可配置化包含的内容非常广泛，这里我们仅仅讨论几个目前可能对我们有用的几个方面。</p>
<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p>一个项目在测试环境与正式环境的访问入口是不同的，像这样的变量我们都会准备一个专门的配置文件来保存，比如laravel中的.env文件。通过配置文件，来达到修改变量，而不是修改代码的目的。</p>
<p>曾经流行的PHP系统中，往往会提供在后台管理配置项的功能，将配置项保存在数据库中，现今已不推荐使用这种方式。一来之前的系统很多是面向非程序员的站长的，所以需要配置可视化，但我们目前的系统都是有编程基础的人员进行管理的，直接修改配置文件并不存在门槛；其次，如果通过后台保存在数据库中，需要先连接数据库，然后才能读取配置项，在运行机制上会有一个先后问题，所以并非任意的配置项都能保存到数据库。</p>
<p>一般来说，配置项会满足下列特征中的一个或几个:</p>
<ul>
<li>可调整的值。 </li>
<li>环境变量。 系统入口、环境名称、debug等。</li>
<li>服务间耦合信息。 数据库信息、reids信息等。</li>
</ul>
<h2 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h2><p>配置对象，系统管理后台的所有功能，都可以抽象成对配置对象的管理。拿用户管理功能举例来说：</p>
<ul>
<li>新增用户：为系统新增一个用户对象。</li>
<li>删除用户：删除系统中的某个用户对象。</li>
<li>修改用户密码：修改系统中存在的用户对象的密码属性。</li>
</ul>
<p>配置对象是如何抽象出来的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分析系统需求 -&gt; 构建系统逻辑 -&gt; 抽象系统所需对象 -&gt; 明确对象的属性 -&gt; 对象对应数据库中的表，对象属性对应数据表的字段</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20191025/custom/编码习惯.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20191025/custom/编码习惯.html" itemprop="url">编码习惯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-25T16:07:00+08:00">
                2019-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>单引号与双引号的使用：纯字符串使用单引号包括，而不是使用双引号。</li>
<li><p>字符串与变量的拼接：</p>
<ul>
<li>通过点号(.)连接字符串与变量。</li>
<li>双引号的写法，变量使用中括号包括。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$str = <span class="string">"Hello World. I'm &#123;$name&#125;."</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>同一个方法体内不要用相同的变量表示不同的含义。</p>
</li>
<li><p>foreach循环数组时，as后面避免使用引用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> $key =&gt; &amp; $value) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编码过程中进行逻辑运算时，尽量避免出现无意义的罗马数值，通过使用常量来代替。此外，其他地方为了表意明确，都推荐做如上处理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范</span></span><br><span class="line"><span class="keyword">if</span> ($user-&gt;type == <span class="number">1</span>) &#123;</span><br><span class="line">   $isAdmin = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示范</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> TYPE_ADMIN = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($user-&gt;type == User::TYPE_ADMIN) &#123;</span><br><span class="line">   $isAdmin = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对类型明确的函数参数，进行类型声明。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserName</span><span class="params">($user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $user-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserName</span><span class="params">(User $user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $user-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20191017/你不知道strtotime有多强大.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20191017/你不知道strtotime有多强大.html" itemprop="url">你不知道strtotime有多强大</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T11:12:00+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>关于这个函数，PHP 手册译本是这样描述的：</p>
<blockquote>
<p><strong> strtotime </strong></p>
<p>(PHP 4, PHP 5, PHP 7)<br>strtotime — 将任何字符串的日期时间描述解析为 Unix 时间戳</p>
<p><strong> 说明 </strong></p>
<p><code>int strtotime ( string $time [, int $now = time() ] )</code><br>本函数预期接受一个包含美国英语日期格式的字符串并尝试将其解析为 Unix 时间戳（自 January 1 1970 00:00:00 GMT 起的秒数），其值相对于 <code>now</code> 参数给出的时间，如果没有提供此参数则用系统当前时间。</p>
</blockquote>
<p>原文：</p>
<blockquote>
<p><strong> strtotime </strong></p>
<p>(PHP 4, PHP 5, PHP 7)<br>strtotime — Parse about any English textual datetime description into a Unix timestamp</p>
<p><strong> Description </strong></p>
<p><code>int strtotime ( string $time [, int $now = time() ] )</code><br>The function expects to be given a string containing an English date format and will try to parse that format into a Unix timestamp (the number of seconds since January 1 1970 00:00:00 UTC), relative to the timestamp given in now, or the current time if now is not supplied.</p>
</blockquote>
<p>先按下不表。</p>
<p>关于PHP 中时间格处理，几乎是随处都会用到。在项目中就遇到过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//判断是否为时间格式</span><br><span class="line">function isTimeFormat($str)</span><br><span class="line">&#123;</span><br><span class="line">    return strtotime($str) !== false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一开始并未深究其中逻辑，因为他工作挺正常的。直到最近发现多处日期数据有误，追踪到上述一段代码，才发现并没有这么简单。这段代码是如何引入的呢，通过搜索后发现，网上有很多文章都提到过这一黑科技：<a href="http://www.daimajiayuan.com/sitejs-17065-1.html" target="_blank" rel="noopener">案例</a>、<a href="http://www.jb51.net/article/44817.htm" target="_blank" rel="noopener">案例</a>、<a href="https://zhidao.baidu.com/question/560995893965912404.html" target="_blank" rel="noopener">案例</a>。所以我猜想应该也是在网上查询后加进来的。但是网上找到的案例或多或少都会提到该方法不是特别严格，对于某些特别的情况判断会出错。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/20191017/你不知道strtotime有多强大.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20191016/discuss/what_the_fu..function.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20191016/discuss/what_the_fu..function.html" itemprop="url">PHP坑爹函数系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-16T20:07:00+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><ul>
<li><a href="#前言">前言</a></li>
<li><a href="#strtotime">strtotime</a></li>
<li><a href="#trim">trim</a></li>
<li><a href="#getimagesize">getimagesize</a></li>
<li><a href="#realpath">realpath</a></li>
<li><a href="#pathinfo">pathinfo</a></li>
<li><a href="#opendir">opendir</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列中指出的问题，绝大部分都是因为对php文档内容不熟悉，或函数说明理解不到位导致的，所以有空多翻翻<a href="https://www.php.net/manual/zh/index.php" target="_blank" rel="noopener">php文档</a>。</p>
<h1 id="strtotime"><a href="#strtotime" class="headerlink" title="strtotime"></a>strtotime</h1><blockquote>
<p>本函数预期接受一个包含美国英语日期格式的字符串并尝试将其解析为 Unix 时间戳（自 January 1 1970 00:00:00 GMT 起的秒数），其值相对于 now 参数给出的时间，如果没有提供此参数则用系统当前时间。</p>
</blockquote>
<p><strong>禁止给strtotime传入变量作为第一个参数。</strong> 因为你不知道这个变量代表的字符会是什么。千万要注意传入的参数，不可以是任意的字符串，否则可能会导致不确定的输出。之前网上流传的一段代码，通过strtotime来判断日期格式是否正确就是很好的错误示范：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$data=<span class="string">'2014-11-11'</span>;<span class="comment">//这里可以任意格式，因为strtotime函数很强大</span></span><br><span class="line">$is_date=strtotime($data)?strtotime($data):<span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>($is_date===<span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">'日期格式非法'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> date(<span class="string">'Y-m-d'</span>,$is_date);<span class="comment">//只要提交的是合法的日期，这里都统一成2014-11-11格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h1><p><code>trim/ltrim/rtrim</code> 这三个函数，原本是用于去除字符串首尾的空白。但这个函数也支持传入第二个参数来指定要过滤的范围。之前的项目中有出现这样的用法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$path = <span class="string">'/Resource/video/video.mp4'</span>;</span><br><span class="line"></span><br><span class="line">$path = ltrim($path, <span class="string">'/Resource'</span>);</span><br></pre></td></tr></table></figure>
<p>本意是想去除字符串的<code>/Resource</code>前缀，但是没想到结果会是 <code>video/video.mp4</code>，更没想到会误伤类似 <code>/Resource/start/video.mp4</code> 等字符串。因为如果第二个参数是一个字符列表的话，会逐个匹配去除，凡是指定的列表中出现的字符，如果在首位，都会被去除，而不是将<code>/Resource</code>作为一个整体去除。</p>
<h1 id="getimagesize"><a href="#getimagesize" class="headerlink" title="getimagesize"></a>getimagesize</h1><p>用于检查指定图片文件的大小，除了可以检查本地文件系统中的文件，还能用于检查网络地址中的文件，这种情况下，就需要考虑因网络延迟导致的性能的问题。之前的项目中遇到过，在某个接口中检查一组网络图片的大小，导致接口返回异常缓慢。</p>
<h1 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h1><p>realpath用于将目录转化成绝对路径。</p>
<blockquote>
<p>realpath() 扩展所有的符号连接并且处理输入的 path 中的 ‘/./‘, ‘/../‘ 以及多余的 ‘/‘ 并返回规范化后的绝对路径名。返回的路径中没有符号连接，’/./‘ 或 ‘/../‘ 成分。</p>
</blockquote>
<p>注意如果指定目录或文件不存在，函数会返回false</p>
<h1 id="pathinfo"><a href="#pathinfo" class="headerlink" title="pathinfo"></a>pathinfo</h1><p>pathinfo有可能出现返回值不正确的情况。这时请注意检查文件名是否包含中文，这可能导致basename为空，解决办法是:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_ALL, <span class="string">'en_US.UTF-8'</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h1><p>在windows下读取映射目录时，有权限的问题。解决方案:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$location = <span class="string">"\\\\ip\web"</span>;</span><br><span class="line">$user     = <span class="string">"root"</span>;</span><br><span class="line">$pass     = <span class="string">"123456youzu"</span>;</span><br><span class="line">$letter   = <span class="string">"Z"</span>;</span><br><span class="line">system(<span class="string">"net use "</span> . $letter . <span class="string">": \""</span> . $location . <span class="string">"\" "</span> . $pass . <span class="string">" /user:"</span> . $user . <span class="string">" /persistent:no&gt;nul 2&gt;&amp;1"</span>);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20191016/standard.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20191016/standard.html" itemprop="url">PHP代码规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-16T19:19:00+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-文件夹"><a href="#1-文件夹" class="headerlink" title="1. 文件夹"></a>1. 文件夹</h2><ul>
<li>文件夹名称<strong>必须</strong>符合 <code>CamelCase</code> 式的大写字母开头驼峰命名规范。</li>
</ul>
<h2 id="2-文件"><a href="#2-文件" class="headerlink" title="2. 文件"></a>2. 文件</h2><ul>
<li><code>PHP</code> 代码文件<strong>必须</strong>以不带 <code>BOM</code> 的 <code>UTF-8</code> 编码。</li>
<li>纯 <code>PHP</code> 代码文件<strong>必须</strong>省略最后的 <code>?&gt;</code> 结束标签。</li>
</ul>
<h2 id="3-行"><a href="#3-行" class="headerlink" title="3. 行"></a>3. 行</h2><ul>
<li>行的长度一定限制在140个字符以内。</li>
<li>非空行后一定不能有多余的空格符。</li>
<li>每行一定不能存在多于一条语句。</li>
<li>适当空行可以使得阅读代码更加方便以及有助于代码的分块（但注意不能滥用空行）。</li>
</ul>
<h2 id="4-缩进"><a href="#4-缩进" class="headerlink" title="4. 缩进"></a>4. 缩进</h2><ul>
<li>代码<strong>必须</strong>使用4个空格符的缩进，一定不能用 <code>tab</code> 键 。</li>
</ul>
<h2 id="5-关键字以及-true-false-null"><a href="#5-关键字以及-true-false-null" class="headerlink" title="5. 关键字以及 true/false/null"></a>5. 关键字以及 <code>true/false/null</code></h2><ul>
<li><code>PHP</code> 所有关键字<strong>必须</strong>全部小写。</li>
<li>常量 <code>true</code>、<code>false</code> 和 <code>null</code> <strong>必须</strong>全部小写。</li>
</ul>
<h2 id="6-namespace-以及-use-声明"><a href="#6-namespace-以及-use-声明" class="headerlink" title="6. namespace 以及 use 声明"></a>6. <code>namespace</code> 以及 <code>use</code> 声明</h2><ul>
<li><code>namespace</code> 声明后<strong>必须</strong>插入一个空白行。</li>
<li>所有 <code>use</code> <strong>必须</strong>在 <code>namespace</code> 后声明。</li>
<li>每条 <code>use</code> 声明语句<strong>必须</strong>只有一个 <code>use</code> 关键词。</li>
<li><code>use</code> 声明语句块后<strong>必须</strong>要有一个空白行。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="title">as</span> <span class="title">Bar</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendorgiOtherPackage</span>\<span class="title">BazClass</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ... additional PHP code ...</span></span><br></pre></td></tr></table></figure>
<h2 id="7-类-class，属性-properties-和方法-methods"><a href="#7-类-class，属性-properties-和方法-methods" class="headerlink" title="7. 类 class，属性 properties 和方法 methods"></a>7. 类 <code>class</code>，属性 <code>properties</code> 和方法 <code>methods</code></h2><p>这里的类是广义的类，它包含所有的类 <code>classes</code> ，接口 <code>interface</code> 和 <code>traits</code>。</p>
<h3 id="7-1-类-class"><a href="#7-1-类-class" class="headerlink" title="7.1 类 class"></a>7.1 类 <code>class</code></h3><ul>
<li>类的命名<strong>必须</strong>遵循大写字母开头的驼峰式命名规范。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constants, properties, methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-extends-和-implements"><a href="#7-2-extends-和-implements" class="headerlink" title="7.2 extends 和 implements"></a>7.2 <code>extends</code> 和 <code>implements</code></h3><ul>
<li>关键词 <code>extends</code> 和 <code>implements</code> <strong>必须</strong>写在类名称的同一行。</li>
<li>类的开始花括号<strong>必须</strong>独占一行，结束花括号也<strong>必须</strong>在类主体后独占一行。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="title">as</span> <span class="title">Bar</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendorgiOtherPackage</span>\<span class="title">BazClass</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> <span class="keyword">implements</span> <span class="title">giArrayAccess</span>, \<span class="title">Countable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constants, properties, methods </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>implements</code> 的继承列表如果超出140个字符也可以分成多行，这样的话，每个继承接口名称都<strong>必须</strong>分开独立成行，包括第一个。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="title">as</span> <span class="title">Bar</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendorgiOtherPackage</span>\<span class="title">BazClass</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> <span class="keyword">implements</span>     </span></span><br><span class="line"><span class="class">    <span class="title">giArrayAccess</span>,     </span></span><br><span class="line"><span class="class">    <span class="title">giCountable</span>,     </span></span><br><span class="line"><span class="class">    <span class="title">giSerializable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="comment">// constants, properties, methods </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-常量-const"><a href="#7-3-常量-const" class="headerlink" title="7.3 常量 const"></a>7.3 常量 <code>const</code></h3><ul>
<li>类的常量中所有字母都<strong>必须</strong>大写，词间以下划线分隔。 </li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooClass</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="title">as</span> <span class="title">Bar</span>; </span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendorgiOtherPackage</span>\<span class="title">BazClass</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> <span class="keyword">implements</span> <span class="title">giArrayAccess</span>, \<span class="title">Countable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> VSESION  = <span class="string">'1.0'</span>;</span><br><span class="line">    <span class="keyword">const</span> SITE_URL = <span class="string">'http://www.xxx.com '</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-属性-properties"><a href="#7-4-属性-properties" class="headerlink" title="7.4  属性 properties"></a>7.4  属性 <code>properties</code></h3><ul>
<li>类的属性命名<strong>必须</strong>遵循小写字母开头的驼峰式命名规范 <code>$camelCase</code>。</li>
<li><strong>必须</strong>对所有属性设置访问控制（如，<code>public</code>，<code>protect</code>，<code>private</code>）。</li>
<li>一定不可使用关键字 <code>var</code> 声明一个属性。</li>
<li>每条语句一定不可定义超过一个属性。</li>
<li>不要使用下划线作为前缀，来区分属性是 <code>protected</code> 或 <code>private</code>。</li>
<li>定义属性时先常量属性再变量属性，先 <code>public</code> 然后 <code>protected</code>，最后 <code>private</code>。</li>
</ul>
<p>以下是属性声明的一个范例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> VSESION = <span class="string">'1.0'</span>;</span><br><span class="line">    <span class="keyword">public</span> $foo = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> $sex;</span><br><span class="line">    <span class="keyword">private</span> $name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-方法-methods"><a href="#7-5-方法-methods" class="headerlink" title="7.5 方法 methods"></a>7.5 方法 <code>methods</code></h3><ul>
<li>方法名称<strong>必须</strong>符合 <code>camelCase()</code> 式的小写字母开头驼峰命名规范。</li>
<li>所有方法都<strong>必须</strong>设置访问控制（如，<code>public</code>，<code>protect</code>，<code>private</code>）。</li>
<li>不要使用下划线作为前缀，来区分方法是 <code>protected</code> 或 <code>private</code>。</li>
<li>方法名称后一定不能有空格符，其开始花括号独占一行，结束花括号<strong>必须</strong>在方法主体后单独成一行。参数左括号后和右括号前一定不能有空格。</li>
<li>一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fooBarBaz</span><span class="params">($storeName, $storeId, array $info = [])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body     </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-6-方法的参数-method-arguments"><a href="#7-6-方法的参数-method-arguments" class="headerlink" title="7.6 方法的参数 method arguments"></a>7.6 方法的参数 <code>method arguments</code></h3><ul>
<li>方法参数名称<strong>必须</strong>符合 <code>camelCase</code> 式的小写字母开头驼峰命名规范</li>
<li>参数列表中，每个参数后面<strong>必须</strong>要有一个空格，而前面一定不能有空格。</li>
<li>有默认值的参数，必须放到参数列表的末尾。</li>
<li>如果参数类型为对像<strong>必须</strong>指定参数类型为具体的类名，如下的 <code>$bazObj</code> 参数。</li>
<li>如果参数类型为 <code>array</code> <strong>必须</strong>指定参数类型为 <code>array</code> 。如下 <code>$info</code>。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span></span><br><span class="line"><span class="class"></span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">($storeName, $storeId, BazClass $bazObj, array $info = [])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表超过140个字符可以分列成多行，这样，包括第一个参数在内的每个参数都<strong>必须</strong>单独成行。</li>
<li>拆分成多行的参数列表后，结束括号以及最后一个参数<strong>必须</strong>写在同一行，其开始花括号可以写在同一行，也可以独占一行；结束花括号<strong>必须</strong>在方法主体后单独成一行。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aVeryLongMethodName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassTypeHint $arg1,</span></span></span><br><span class="line"><span class="function"><span class="params">        &amp;$arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">        array $arg3 = [])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// method body     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-7-abstract-、-final-、-以及-static"><a href="#7-7-abstract-、-final-、-以及-static" class="headerlink" title="7.7 abstract 、 final 、 以及 static"></a>7.7 <code>abstract</code> 、 <code>final</code> 、 以及 <code>static</code></h3><ul>
<li>需要添加 <code>abstract</code> 或 <code>final</code> 声明时， <strong>必须</strong>写在访问修饰符前，而 <code>static</code> 则<strong>必须</strong>写在其后。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> $foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">zim</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-8-方法及方法调用"><a href="#7-8-方法及方法调用" class="headerlink" title="7.8 方法及方法调用"></a>7.8 方法及方法调用</h3><ul>
<li>方法及方法调用时，方法名与参数左括号之间一定不能有空格，参数右括号前也一定不能有空格。每个参数前一定不能有空格，但其后必须有一个空格。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">bar(); </span><br><span class="line">$foo-&gt;bar($arg1); </span><br><span class="line">Foo::bar($arg2, $arg3);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表超过140个字符可以分列成多行，此时包括第一个参数在内的每个参数都<strong>必须</strong>单独成行。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$foo-&gt;bar(</span><br><span class="line">    $longArgument,</span><br><span class="line">    $longerArgument,</span><br><span class="line">    $muchLongerArgument);</span><br></pre></td></tr></table></figure>
<h2 id="8-控制结构-control-structures"><a href="#8-控制结构-control-structures" class="headerlink" title="8. 控制结构 control structures"></a>8. 控制结构 <code>control structures</code></h2><p>控制结构的基本规范如下：</p>
<ul>
<li>控制结构关键词后<strong>必须</strong>有一个空格。</li>
<li>左括号 <code>(</code> 后一定不能有空格。</li>
<li>右括号 <code>)</code> 前也一定不能有空格。</li>
<li>右括号 <code>)</code> 与开始花括号 <code>{</code> 间一定有一个空格。</li>
<li>结构体主体一定要有一次缩进。</li>
<li>结束花括号 <code>}</code> 一定在结构体主体后单独成行。</li>
<li>每个结构体的主体都<strong>必须</strong>被包含在成对的花括号之中， 这能让结构体更加标准，以及减少加入新行时，引入出错的可能性。</li>
</ul>
<h3 id="8-1-if-、-elseif-和-else"><a href="#8-1-if-、-elseif-和-else" class="headerlink" title="8.1 if 、 elseif 和 else"></a>8.1 <code>if</code> 、 <code>elseif</code> 和 <code>else</code></h3><ul>
<li>标准的 <code>if</code> 结构如下代码所示，留意 括号、空格以及花括号的位置， 注意 <code>else</code> 和 <code>elseif</code> 都与前面的结束花括号在同一行。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($expr1) &#123;</span><br><span class="line">    <span class="comment">// if body </span></span><br><span class="line">&#125; <span class="keyword">elseif</span> ($expr2) &#123;</span><br><span class="line">    <span class="comment">// elseif body </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else body; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个if也必须带有花括号</span></span><br><span class="line"><span class="keyword">if</span> ($expr1) &#123;</span><br><span class="line">    <span class="comment">// if body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该使用关键词 <code>elseif</code> 代替所有 <code>else if</code> ，以使得所有的控制关键字都像是单独的一个词。</p>
<h3 id="8-2-switch-和-case"><a href="#8-2-switch-和-case" class="headerlink" title="8.2 switch 和 case"></a>8.2 <code>switch</code> 和 <code>case</code></h3><p>标准的 <code>switch</code> 结构如下代码所示，留意括号、空格以及花括号的位置。 <code>case</code> 语句必须相对 <code>switch</code> 进行一次缩进，而 <code>break</code> 语句以及 <code>case</code> 内的其它语句都 必须 相对 <code>case</code> 进行一次缩进。 如果存在非空的 <code>case</code> 直穿语句，主体里必须有类似 <code>// no break</code> 的注释。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ($expr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'First case, with a break'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Second case, which falls through'</span>;</span><br><span class="line">        <span class="comment">// no break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Third case, return instead of break'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Default case'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-while-和-do-while"><a href="#8-3-while-和-do-while" class="headerlink" title="8.3 while 和 do while"></a>8.3 <code>while</code> 和 <code>do while</code></h3><p>一个规范的 <code>while</code> 语句应该如下所示，注意其 括号、空格以及花括号的位置。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($expr) &#123;</span><br><span class="line">    <span class="comment">// structure body </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准的 <code>do while</code> 语句如下所示，同样的，注意其 括号、空格以及花括号的位置。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// structure body; </span></span><br><span class="line">&#125; <span class="keyword">while</span> ($expr);</span><br></pre></td></tr></table></figure>
<h3 id="8-4-for"><a href="#8-4-for" class="headerlink" title="8.4 for"></a>8.4 <code>for</code></h3><p>标准的 <code>for</code> 语句如下所示，注意其 括号、空格以及花括号的位置。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    <span class="comment">// for body </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-foreach"><a href="#8-5-foreach" class="headerlink" title="8.5 foreach"></a>8.5 <code>foreach</code></h3><p>标准的 <code>foreach</code> 语句如下所示，注意其 括号、空格以及花括号的位置。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($iterable <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">    <span class="comment">// foreach body </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-6-try-catch"><a href="#8-6-try-catch" class="headerlink" title="8.6 try, catch"></a>8.6 <code>try</code>, <code>catch</code></h3><p>标准的 <code>try catch</code> 语句如下所示，注意其 括号、空格以及花括号的位置。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// try body </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FirstExceptionType $e) &#123;</span><br><span class="line">    <span class="comment">// catch body </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (OtherExceptionType $e) &#123;</span><br><span class="line">    <span class="comment">// catch body </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9 闭包"></a>9 闭包</h2><ul>
<li>闭包声明时，关键词 <code>function</code> 后以及关键词 <code>use</code> 的前后都<strong>必须</strong>要有一个空格。</li>
<li>开始花括号<strong>必须</strong>写在声明的下一行，结束花括号<strong>必须</strong>紧跟主体结束的下一行。</li>
<li>参数列表和变量列表的左括号后以及右括号前，<strong>必须</strong>不能有空格。</li>
<li>参数和变量列表中，逗号前<strong>必须</strong>不能有空格，而逗号后<strong>必须</strong>要有空格。</li>
<li>闭包中有默认值的参数<strong>必须</strong>放到列表的后面。</li>
<li>标准的闭包声明语句如下所示，注意其 括号、逗号、空格以及花括号的位置。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$closureWithArgs = <span class="function"><span class="keyword">function</span> <span class="params">($arg1, $arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// body </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$closureWithArgsAndVars = <span class="function"><span class="keyword">function</span> <span class="params">($arg1, $arg2)</span> <span class="title">use</span> <span class="params">($var1, $var2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// body </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表以及变量列表可以分成多行，这样，包括第一个在内的每个参数或变量都<strong>必须</strong>单独成行。</li>
</ul>
<p>以下几个例子，包含了参数和变量列表被分成多行的多情况。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$longArgsNoVars = <span class="function"><span class="keyword">function</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    $longArgument,</span></span></span><br><span class="line"><span class="function"><span class="params">    $longerArgument,</span></span></span><br><span class="line"><span class="function"><span class="params">    $muchLongerArgument)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$noArgsLongVars = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    $longVar1,</span></span></span><br><span class="line"><span class="function"><span class="params">    $longerVar2,</span></span></span><br><span class="line"><span class="function"><span class="params">    $muchLongerVar3)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$longArgsLongVars = <span class="function"><span class="keyword">function</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    $longArgument,</span></span></span><br><span class="line"><span class="function"><span class="params">    $longerArgument,</span></span></span><br><span class="line"><span class="function"><span class="params">    $muchLongerArgument)</span> <span class="title">use</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    $longVar1,</span></span></span><br><span class="line"><span class="function"><span class="params">    $longerVar2,</span></span></span><br><span class="line"><span class="function"><span class="params">    $muchLongerVar3)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$longArgsShortVars = <span class="function"><span class="keyword">function</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    $longArgument,</span></span></span><br><span class="line"><span class="function"><span class="params">    $longerArgument,</span></span></span><br><span class="line"><span class="function"><span class="params">    $muchLongerArgument)</span> <span class="title">use</span> <span class="params">($var1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$shortArgsLongVars = <span class="function"><span class="keyword">function</span> <span class="params">($arg)</span> <span class="title">use</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    $longVar1,</span></span></span><br><span class="line"><span class="function"><span class="params">    $longerVar2,</span></span></span><br><span class="line"><span class="function"><span class="params">    $muchLongerVar3)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，闭包被直接用作函数或方法调用的参数时，以上规则仍然适用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$foo-&gt;bar(</span><br><span class="line">    $arg1,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">($arg2)</span> <span class="title">use</span> <span class="params">($var1)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">    &#125;, $arg3);</span><br></pre></td></tr></table></figure>
<h2 id="10-注释"><a href="#10-注释" class="headerlink" title="10  注释"></a>10  注释</h2><h3 id="10-1-文件注释"><a href="#10-1-文件注释" class="headerlink" title="10.1 文件注释"></a>10.1 文件注释</h3><ul>
<li>注释开始应该使用 <code>/*</code>， 不可以使用 <code>/**</code>；结束应该使用 <code>*/</code>； 不可以使用 <code>**/</code>。</li>
<li>第二行php版本信息，版本信息后一空行。</li>
<li>注解内容对齐，注解之间不可有空行。</li>
<li>星号和注释内容中间必须是一个空格。</li>
<li>保持注解顺序一致 <code>@copyright</code> 然后　<code>@link</code>　再　<code>@license</code>。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PHP version 5.5</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@copyright</span> Copyright (c) 2005-2015 XXXX. (http://www.xxx.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span>       http://www.xxx.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@license</span>    xxx公司版权所有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aVeryLongMethodName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassTypeHint $arg1,</span></span></span><br><span class="line"><span class="function"><span class="params">        &amp;$arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">        array $arg3 = [])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-类注释"><a href="#10-2-类注释" class="headerlink" title="10.2 类注释"></a>10.2 类注释</h3><ul>
<li>注释开始应该使用 <code>/**</code>, 不可以使用 <code>/*</code>;结束应该使用 <code>*/</code>， 不可以使用 <code>**/</code>。</li>
<li>第二行开始描述，描述后一空行。</li>
<li>注解内容对齐，注解之间不可有空行。</li>
<li>星号和注释内容中间必须是一个空格。</li>
<li>保持注解顺序一致 <code>@author</code> 然后 <code>@since</code> 再 <code>@version</code>。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">VendorgiPackage</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我是类描述信息哦！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   2015年1月12日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aVeryLongMethodName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassTypeHint $arg1,</span></span></span><br><span class="line"><span class="function"><span class="params">        &amp;$arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">        array $arg3 = [])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-属性注释"><a href="#10-3-属性注释" class="headerlink" title="10.3 属性注释"></a>10.3 属性注释</h3><ul>
<li>注释开始应该使用 <code>/**</code>， 不可以使用 <code>/*</code>，结束应该使用 <code>*/</code>， 不可以使用 <code>**/</code>。</li>
<li>星号和注释内容中间必须是一个空格。</li>
<li>使用 <code>var</code> 注解并注明类型。</li>
<li>注解基本类型包括 <code>int</code>、<code>sting</code>、<code>array</code>、<code>boolea</code>、具体类名称。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $cacheKey = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $cacheTime = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> \CacheServer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $cacheObj = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-4-方法注释"><a href="#10-4-方法注释" class="headerlink" title="10.4 方法注释"></a>10.4 方法注释</h3><ul>
<li>注释开始应该使用 <code>/**</code>， 不可以使用 <code>/*</code>；结束应该使用 <code>*/</code>， 不可以使用 <code>**/</code>。</li>
<li>第二行开始方法描述，方法描述后一空行。</li>
<li>注解内容对齐，注解之间不可有空行。</li>
<li>星号和注释内容中间必须是一个空格。</li>
<li>注解顺序为 <code>@param</code>，<code>@return</code>，<code>@author</code> 和 <code>@since</code>，参数的顺序必须与方法参数顺序一致。</li>
<li>参数和返回值注解包括基本类型（<code>int/sting/array/boolean/unknown</code>）和对象，如果多个可能类型使用 <code>|</code> 分割。</li>
<li>如果参数类型为对像必须指定参数类型为具体的类名，如下的 <code>$arg1</code> 参数。</li>
<li>如果参数类型为 <code>array</code> 必须指定参数类型为 <code>array</code> 。如下 <code>$arg2</code>。</li>
<li>需要作者和日期注解，日期为最后修改日期。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 我是方法描述信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ClassName $arg1 参数1描述　我是具体的对象类型哦</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $arg2 参数2描述　我是数据类型哦</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $arg3 参数3描述  我是基本数据类型哦</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  2015年1月12日</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">methodName</span><span class="params">(ClassName $arg1, array $arg2, $arg3)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="comment">// method body</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-5-其他注释"><a href="#10-5-其他注释" class="headerlink" title="10.5 其他注释"></a>10.5 其他注释</h3><ul>
<li>代码注释尽量使用 <code>//</code></li>
<li>注释内容开始前必须一个空格</li>
<li>代码行尾注释 <code>//</code> 前面必须一个空格</li>
<li>代码注释与下面的代码对齐</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">methodName</span><span class="params">(ClassName $arg1, array $arg2, $arg3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里是注释哦 注释内容前是有一个空格的哦</span></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++) &#123;</span><br><span class="line">            <span class="comment">// for body 注释和下面的代码是对齐的哦</span></span><br><span class="line">            $a++; <span class="comment">// 代码行尾注释‘//’前面必须一个空格</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多行注释时使用 <code>/* *  ......*/</code></li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">methodName</span><span class="params">(ClassName $arg1, array $arg2, $arg3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  这是多行注释哦</span></span><br><span class="line"><span class="comment">         *　这是多行注释哦</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++) &#123;</span><br><span class="line">            <span class="comment">// for body</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20190802/laravel/eloquent-article.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20190802/laravel/eloquent-article.html" itemprop="url">laravel ORM源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-02T12:50:00+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在web应用中，与数据库的交互可以说是最常用且最重要的操作。作为当前最流行的php框架之一，laravel对数据库操作的封装，可以说是非常优秀了。在官方文档当中，数据库的使用说明文档占据了两个大章节，分别是【数据库】与【Eloquent ORM】，为什么针对同一功能，官方要出两个文档呢？是因为它重要？复杂？对此我无从猜测，不过可以从源码中窥知一二。</p>
<h1 id="一、-Eloquent的生命周期"><a href="#一、-Eloquent的生命周期" class="headerlink" title="一、 Eloquent的生命周期"></a>一、 Eloquent的生命周期</h1><p>在laravel应用的生命周期里，数据库部分出现在第二阶段，容器启动阶段。更精确的说，是容器启动阶段的服务提供者注册/启动阶段。数据库服务的入口，是数据库的服务提供者，即<code>Illuminate\Database\DatabaseServiceProvider</code>。</p>
<p>DatabaseServiceProvider的注册方法如代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public function register()</span><br><span class="line">&#123;</span><br><span class="line">    Model::clearBootedModels();</span><br><span class="line"></span><br><span class="line">    $this-&gt;registerConnectionServices();</span><br><span class="line"></span><br><span class="line">    $this-&gt;registerEloquentFactory();</span><br><span class="line"></span><br><span class="line">    $this-&gt;registerQueueableEntityResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>registerConnectionServices()</code>方法注册了三个别名服务，分别是<code>db.factor/db/db.connection</code>。db用于管理数据库连接；db.factor用于创建数据库连接；而db.connection绑定了一个可用的连接对象。值得一提的是，db.connection是通过bind方法绑定闭包到容器当中，所以在注册阶段并未实例化，而是在真正 需要进行数据连接时实例化连接对象，然后替换原来的闭包。</p>
<p><code>registerEloquentFactory()</code>方法注册了数据填充功能中的数据工厂，用于生成模拟数据。<code>registerQueueableEntityResolver()</code>方法注册了队列的数据库实现。</p>
<p>接着，在DatabaseServiceProvider的启动方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public function boot()</span><br><span class="line">&#123;</span><br><span class="line">    Model::setConnectionResolver($this-&gt;app[&apos;db&apos;]);</span><br><span class="line"></span><br><span class="line">    Model::setEventDispatcher($this-&gt;app[&apos;events&apos;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别调用了Model的两个静态方法<code>setConnectionResolver()/setEventDispatcher()</code>，加上注册方法中的<code>clearBootedModels()</code>，完成了Eloquent ORM的Model类的全局设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model::clearBootedModels();</span><br><span class="line">Model::setConnectionResolver($this-&gt;app[&apos;db&apos;]);</span><br><span class="line">Model::setEventDispatcher($this-&gt;app[&apos;events&apos;]);</span><br></pre></td></tr></table></figure>
<h1 id="二、-楔子-Eloquent-ORM的使用"><a href="#二、-楔子-Eloquent-ORM的使用" class="headerlink" title="二、 楔子 - Eloquent ORM的使用"></a>二、 楔子 - Eloquent ORM的使用</h1><p>我们先回顾一下官方文档中，关于ORM的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 静态调用</span><br><span class="line">User::all();</span><br><span class="line">User::find(1);</span><br><span class="line">User::where();</span><br><span class="line"></span><br><span class="line">// 2. 对象调用</span><br><span class="line">$flight = App\Flight::find(1);</span><br><span class="line">$flight-&gt;name = &apos;New Flight Name&apos;;</span><br><span class="line">$flight-&gt;save();</span><br><span class="line">$filght-&gt;delete();</span><br></pre></td></tr></table></figure>
<p>Eloquent ORM既可以通过静态调用执行方法，也可以先获取到模型对象，然后执行方法。但他们实质是一样的。在Model中定义的静态方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected static function boot()</span><br><span class="line">protected static function bootTraits()</span><br><span class="line">public static function clearBootedModels()</span><br><span class="line">public static function on($connection = null)</span><br><span class="line">public static function onWriteConnection()</span><br><span class="line">public static function all($columns = [&apos;*&apos;])</span><br><span class="line">public static function with($relations)</span><br><span class="line">public static function destroy($ids)</span><br><span class="line">public static function query()</span><br><span class="line">public static function resolveConnection($connection = null)</span><br><span class="line">public static function getConnectionResolver()</span><br><span class="line">public static function setConnectionResolver(Resolver $resolver)</span><br><span class="line">public static function unsetConnectionResolver()</span><br><span class="line">public static function __callStatic($method, $parameters)</span><br></pre></td></tr></table></figure>
<p>可以看到，形如<code>User::find(1)/User::where()</code>的静态调用方法，本身不在类中有定义，而是转发到__callStatic魔术方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static function __callStatic($method, $parameters)</span><br><span class="line">&#123;</span><br><span class="line">    return (new static)-&gt;$method(...$parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是先实例化自身，然后在对象上执行调用。所以，在使用Eloquent的过程中，模型基本上都会有实例化的过程，然后再对象的基础上进行方法的调用。那么我们看看Model的构造方法中，都做了哪些动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function __construct(array $attributes = [])</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;bootIfNotBooted();</span><br><span class="line"></span><br><span class="line">    $this-&gt;syncOriginal();</span><br><span class="line"></span><br><span class="line">    $this-&gt;fill($attributes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bootIfNotBooted()</code>是模型的启动方法，标记模型被启动，并且触发模型启动的前置与后置事件。在启动过程中，会查询模型使用的trait中是否包含<code>boot{Name}</code>形式的方法，有的话就执行，这个步骤可以为模型扩展一些功能，比如文档中的软删除：</p>
<blockquote>
<p>要在模型上启动软删除，则必须在模型上使用 Illuminate\Database\Eloquent\SoftDeletes trait 并添加 deleted_at 字段到你的 $dates 属性上。</p>
</blockquote>
<p>就是在启动<code>SoftDeletes</code>traits的时候，给模型添加了一组查询作用域，来新增<code>Restore()/WithTrashed()/WithoutTrashed()/OnlyTrashed()</code>四个方法，同时改写delete方法的逻辑，从而定义了软删除的相关行为。</p>
<p><code>syncOriginal()</code>方法的作用在于保存原始对象数据，当更新对象的属性时，可以进行脏检查。</p>
<p><code>fill($attributes)</code>就是初始化模型的属性。</p>
<p>在实际运用中可能会注意到，我们很少会用new的方法、通过构造函数来实例化模型对象，但在后续我们要说道的查询方法中，会有一个<code>装载对象</code>的过程，有这样的用法。为什么我们很少会new一个Model，其实原因两个方面：首先从逻辑上说，是先有一条数据库记录，然后才有基于该记录的数据模型，所以在new之前必然要有查询数据库的动作；其次是因为直接new出来的Model，它的状态有可能并不正确，需要手动进行设置，可以查阅Model的<code>newInstance()/newFromBuilder()</code>两个方法来理解“状态不正确”的含义。</p>
<h1 id="三、-深入-Eloquent-ORM的查询过程"><a href="#三、-深入-Eloquent-ORM的查询过程" class="headerlink" title="三、 深入 - Eloquent ORM的查询过程"></a>三、 深入 - Eloquent ORM的查询过程</h1><p>我们以<code>User::all()</code>的查询过程来作为本小节的开始，Model的all()方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static function all($columns = [&apos;*&apos;])</span><br><span class="line">&#123;</span><br><span class="line">    return (new static)-&gt;newQuery()-&gt;get(</span><br><span class="line">        is_array($columns) ? $columns : func_get_args()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个查询过程，可以分成三个步骤来执行:</p>
<ul>
<li><code>new static</code>: 模型实例化，得到模型对象。</li>
<li><code>$model-&gt;newQuery()</code>: 根据模型对象，获取查询构造器$query。</li>
<li><code>$query-&gt;get($columns)</code>: 根据查询构造器，取得模型数据集合。</li>
</ul>
<p>Eloquent ORM的查询过程，就可以归纳成这三个过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[模型对象]=&gt;[查询构造器]=&gt;[数据集合]</span><br></pre></td></tr></table></figure>
<p>数据集合也是模型对象的集合，即使是做<code>first()</code>查询，也是先获取到只有一个对象的数据集合，然后取出第一个对象。但数据集合中的模型对象，与第一步中的模型对象不是同一个对象，作用也不一样。第一步实例化得到的模型对象，是一个<code>空对象</code>，其作用是为了获取第二步的查询构造器，第三步中的模型对象，是经过数据库查询，获取到数据后，对数据进行封装后的对象，是一个有数据的对象，从查询数据到模型对象的过程，我称之为<code>装载对象</code>，装载对象，正是使用的上文提及的<code>newFromBuilder()</code>方法。</p>
<p><code>newQuery()</code>的调用过程很长，概括如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newQuery()</span><br><span class="line">--&gt;newQueryWithoutScopes()  // 添加查询作用域</span><br><span class="line">--&gt;newModelQuery() // 添加对关系模型的加载</span><br><span class="line">--&gt;newEloquentBuilder(newBaseQueryBuilder()) // 获取查询构造器</span><br><span class="line">--&gt; return new Builder(new QueryBuilder()) // 查询构造器的再封装</span><br></pre></td></tr></table></figure>
<p>它引出了Eloquent ORM中的一个重要概念，叫做$query，查询构造器，虽然官方文档中，有大篇幅关于Model的使用说明，但其实很多方法都会转发给$query去执行。从最后的一次调用可以看出，有两个查询构造器，分别是：</p>
<ul>
<li>数据库查询构造器：Illuminate\Database\Query\Builder</li>
<li>Eloquent ORM查询构造器：Illuminate\Database\Eloquent\Builder</li>
</ul>
<blockquote>
<p>备注：</p>
<ol>
<li>由于两个类名一致，我们约定当提到Builder时，我们指的是Illuminate\Database\Query\Builder;当提到EloquentBuilder时，我们指的是Illuminate\Database\Eloquent\Builder。</li>
<li>在代码中，Builder或EloquentBuilder的实例一般用变量$query来表示</li>
</ol>
</blockquote>
<p>这两个查询构造器的存在，解释了本文开头提到的问题：为什么关于数据库的文档说明，会分为两个章节？因为一章是对<code>Illuminate\Database\Query\Builder</code>的说明，另一章是对<code>Illuminate\Database\Eloquent\Builder</code>的说明(直观的理解为对Model的说明)。</p>
<p>数据库查询构造器Builder定义了一组通用的，人性化的操作接口，来描述将要执行的SQL语句（见官方文档【数据库 - 查询构造器】一章。）在这一层提供的接口更接近SQL原生的使用方法，比如：<code>where/join/select/insert/delete/update</code>等，都很容易在数据库的体系内找到相应的操作或指令；EloquentBuilder是对Builder的再封装，EloquentBuilder在Builder的基础之上，定义了一些更复杂，但更便捷的描述接口（见官方文档【Eloquent ORM - 快速入门】一章。），比如：<code>first/firstOrCreate/paginator</code>等。</p>
<h2 id="3-1-EloquentBuilder"><a href="#3-1-EloquentBuilder" class="headerlink" title="3.1 EloquentBuilder"></a>3.1 EloquentBuilder</h2><p>EloquentBuilder是Eloquent ORM查询构造器，是比较高级的能与数据库交互的对象。一般在Model层面的与数据库交互的方法，都会转发到Model的EloquentBuilder对象上去执行，通过下列方法可以获取到一个Eloquent对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$query = User::query();</span><br><span class="line">$query = User::select();</span><br></pre></td></tr></table></figure>
<p>每个EloquentBuilder对象都会有一个Builder成员对象。</p>
<h2 id="3-2-Builder"><a href="#3-2-Builder" class="headerlink" title="3.2 Builder"></a>3.2 Builder</h2><p>Builder是数据库查询构造器，在Builder层面已经可以与数据库进行交互了，如何获取到一个Builder对象呢？下面展示两种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取Builder对象</span><br><span class="line">$query = DB::table(&apos;user&apos;);</span><br><span class="line">$query = User::query()-&gt;getQuery();</span><br><span class="line"></span><br><span class="line">// Builder对象与数据库交互</span><br><span class="line">$query-&gt;select(&apos;name&apos;)-&gt;where(&apos;status&apos;, 1)-&gt;orderBy(&apos;id&apos;)-&gt;get();</span><br></pre></td></tr></table></figure>
<p>Builder有三个成员对象:</p>
<ul>
<li>ConnectionInterface</li>
<li>Grammar</li>
<li>Processor</li>
</ul>
<p><strong>ConnectionInterface</strong></p>
<p>ConnectionInterface对象是执行SQL语句、对读写分离连接进行管理的对象，也就是数据库连接对象。是最初级的、能与数据交互的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB::select(&apos;select * from users where active = ?&apos;, [1]);</span><br><span class="line">DB::insert(&apos;insert into users (id, name) values (?, ?)&apos;, [1, &apos;Dayle&apos;]);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>虽然DB门面指向的是<code>Illuminate\Database\DatabaseManager</code>的实例，但是对数据库交互上的操作，都会转发到connection上去执行。</p>
</blockquote>
<p>回头看本文中 <a href="#Eloquent的生命周期">Eloquent的生命周期</a> 关于DatabaseServiceProvider的启动方法的描述，DatabaseServiceProvider的启动方法中执行的代码 <code>Model::setConnectionResolver($this-&gt;app[&#39;db&#39;]);</code> ，这个步骤就是为了后续获取Builder的第一个成员对象<code>ConnectionInterface</code>，数据库连接对象。前文提到过，数据库的连接并不是在服务提供者启动时进行的，是在做出查询动作时才会连接数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Illuminate\Database\Eloquent\Model::class</span><br><span class="line">protected function newBaseQueryBuilder()</span><br><span class="line">&#123;</span><br><span class="line">    // 获取数据库连接</span><br><span class="line">    $connection = $this-&gt;getConnection();</span><br><span class="line"></span><br><span class="line">    // Builder实例化时传入的三个对象，ConnectionInterface、Grammar、Processor</span><br><span class="line">    return new QueryBuilder(</span><br><span class="line">        $connection, $connection-&gt;getQueryGrammar(), $connection-&gt;getPostProcessor()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getConnection()</span><br><span class="line">&#123;</span><br><span class="line">    return static::resolveConnection($this-&gt;getConnectionName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static function resolveConnection($connection = null)</span><br><span class="line">&#123;</span><br><span class="line">    // 使用通过Model::setConnectionResolver($this-&gt;app[&apos;db&apos;])注入的resolver进行数据库的连接</span><br><span class="line">    return static::$resolver-&gt;connection($connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Grammar</strong></p>
<p>Grammar对象是SQL语法解析对象，我们在Builder对象中调用的方法，会以Builder属性的形式将调用参数管理起来，然后在调用SQL执行方法时，先通过Grammar对象对这些数据进行解析，解析出将要执行的SQL语句，然后交给ConnectionInterface执行，获取到数据。</p>
<p><strong>Processor</strong></p>
<p>Processor对象的作用比较简单，将查询结果数据返回给Builder，包括查询的行数据，插入后的自增ID值。</p>
<h2 id="3-3-SELECT语句的描述"><a href="#3-3-SELECT语句的描述" class="headerlink" title="3.3 SELECT语句的描述"></a>3.3 SELECT语句的描述</h2><p>在Builder对象中，关于数据库查询语句的描述，被分成12个部分:</p>
<ul>
<li>aggregate: 聚合查询列描述，该部分与columns互斥</li>
<li>columns: 查询列描述</li>
<li>from: 查询表描述</li>
<li>joins: 聚合表描述</li>
<li>wheres: 查询条件描述</li>
<li>groups: 分组描述</li>
<li>havings: 分组条件描述</li>
<li>orders: 排序条件描述</li>
<li>limit: 限制条数描述</li>
<li>offset: 便宜了描述</li>
<li>unions: 组合查询描述</li>
<li>lock: 锁描述</li>
</ul>
<p>其中，关于wherers的描述提供了相当丰富的操作接口，在实现这部分的接口时，在查询构造器Builder中将where操作分成了以下类型： <code>Basic/Column/In/NotIn/NotInSub/InSub/NotNull/Null/between/Nested/Sub/NotExists/Exists/Raw</code>。wheres条件的组装在 <code>Illuminate\Database\Query\Grammars\Grammar::compileWheres()</code> 方法中完成，每种类型都由两个部分组成：<code>逻辑符号 + 条件表达式</code>，逻辑符号包含<code>and/or</code>。多个where条件直接连接后，通过Grammar::removeLeadingBoolean去掉头部的逻辑符号，组装成最终的条件部分。如果有 <code>Nested</code> 的wheres描述，对Nested的部分单独执行<code>compileWheres</code>后，用括号包装起来形成一个复合的 <code>条件表达式</code>。</p>
<p>wheresTable:</p>
<table>
<thead>
<tr>
<th>type</th>
<th>boolean</th>
<th>condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Basic</td>
<td><del>and</del> (Grammar::removeLeadingBoolean)</td>
<td>id = 1</td>
</tr>
<tr>
<td>Column</td>
<td>and</td>
<td>table1.column1 = table2.column2</td>
</tr>
<tr>
<td>Nested</td>
<td>and</td>
<td>(wheresTable)</td>
</tr>
</tbody>
</table>
<p>最终组合成的Sql语句就是 <code>id = 1 and table1.column1 = table2.column2 and (...)</code>。</p>
<p>where用法的一些注意事项：</p>
<ul>
<li>where的第一个参数是数组或闭包时，条件被描述为Nested类型，也就是参数分组。</li>
<li>where的第二个参数，比较符号是等于号时，可以省略。</li>
<li>where的第三个参数是闭包时，表示一个子查询</li>
</ul>
<h2 id="3-4-join语句的描述"><a href="#3-4-join语句的描述" class="headerlink" title="3.4 join语句的描述"></a>3.4 join语句的描述</h2><p>每次对Builder执行join操作时，都会新建一个JoinClause对象，在文档中关于高级 Join 语法的说明中，有非常类似于where参数分组的用法，就是由闭包导入查询条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// join高级用法</span><br><span class="line">DB::table(&apos;users&apos;)</span><br><span class="line">    -&gt;join(&apos;contacts&apos;, function ($join) &#123;</span><br><span class="line">        $join-&gt;on(&apos;users.id&apos;, &apos;=&apos;, &apos;contacts.user_id&apos;)-&gt;orOn(...);</span><br><span class="line">    &#125;)</span><br><span class="line">    -&gt;get();</span><br><span class="line"></span><br><span class="line">// where参数分组</span><br><span class="line">DB::table(&apos;users&apos;)</span><br><span class="line">    -&gt;where(&apos;name&apos;, &apos;=&apos;, &apos;John&apos;)</span><br><span class="line">    -&gt;orWhere(function ($query) &#123;</span><br><span class="line">        $query-&gt;where(&apos;votes&apos;, &apos;&gt;&apos;, 100)</span><br><span class="line">              -&gt;where(&apos;title&apos;, &apos;&lt;&gt;&apos;, &apos;Admin&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    -&gt;get();</span><br></pre></td></tr></table></figure>
<p>实际上JoinClause继承自Builder，所以上述代码中的闭包参数$join，后面也是可以链式调用where系列函数的。与Builder对象的区别在于扩展了一个on方法，on方法类似于whereColumn，条件的两边是对表字段的描述。</p>
<p>Builder调用join方法时传入的条件，会以<code>Nested</code>的类型添加到JoinClause对象当中，然后将JoinClause对象加入到Builder的joins部分。join结构的组装与wheres类似，会单独对JoinClause对象进行一次compileWheres，然后组装到整体SQL语句中：<code>&quot;{$join-&gt;type} join {$table} {$this-&gt;compileWheres($join)}&quot;</code>。</p>
<h1 id="四、-高级-读写分离的实现"><a href="#四、-高级-读写分离的实现" class="headerlink" title="四、 高级 - 读写分离的实现"></a>四、 高级 - 读写分离的实现</h1><p>读写分离的问题在connection的范畴。当模型实例化Builder的时候，会先去获取一个connection，如果有配置读写分离，先获取一个writeConnection，然后获取一个readConnection，并绑定到writeConnection上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Illuminate\Database\Connectors\ConnectionFactory</span><br><span class="line">public function make(array $config, $name = null)</span><br><span class="line">&#123;</span><br><span class="line">    $config = $this-&gt;parseConfig($config, $name);</span><br><span class="line"></span><br><span class="line">    if (isset($config[&apos;read&apos;])) &#123;</span><br><span class="line">        return $this-&gt;createReadWriteConnection($config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;createSingleConnection($config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected function createReadWriteConnection(array $config)</span><br><span class="line">&#123;</span><br><span class="line">    $connection = $this-&gt;createSingleConnection($this-&gt;getWriteConfig($config));</span><br><span class="line"></span><br><span class="line">    return $connection-&gt;setReadPdo($this-&gt;createReadPdo($config));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意此时的writeConnection与readConnection并不会真正的连接数据库，而是一个闭包，保存了获取连接的方法，当第一次需要连接数据时，执行闭包获取到连接，并将该连接替换掉闭包，后续执行SQL语句时直接使用该连接即可。在实际使用过程中，可能读写连接的使用并不能简单的按照定义而来，有时需要主动设置要使用的连接。</p>
<h2 id="4-1-读连接的使用判定"><a href="#4-1-读连接的使用判定" class="headerlink" title="4.1 读连接的使用判定"></a>4.1 读连接的使用判定</h2><p>在配置读写分离后，默认查询会使用readConnection，以下情况会使用writeConnection：</p>
<ul>
<li>对select操作指定为write：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// connection 级别指定</span><br><span class="line">Illuminate\Database\Connection::select($query, $bindings = [], $useReadPdo = true);</span><br><span class="line"></span><br><span class="line">// Builder 级别指定</span><br><span class="line">DB::table(&apos;user&apos;)-&gt;useWritePdo()-&gt;get();</span><br><span class="line"></span><br><span class="line">// Model 级别指定</span><br><span class="line">Model::onWriteConnection()-&gt;get()</span><br></pre></td></tr></table></figure>
<ul>
<li>查询时启用锁</li>
<li>启用事务</li>
<li>启用sticky配置且前文有写操作</li>
<li>在队列执行时，读取SerializesModels的模型数据时</li>
</ul>
<p>关于其判定逻辑的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Illuminate\Database\Connection::getReadPdo():</span><br><span class="line">public function getReadPdo()</span><br><span class="line">&#123;</span><br><span class="line">    if ($this-&gt;transactions &gt; 0) &#123;</span><br><span class="line">        return $this-&gt;getPdo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($this-&gt;getConfig(&apos;sticky&apos;) &amp;&amp; $this-&gt;recordsModified) &#123;</span><br><span class="line">        return $this-&gt;getPdo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ($this-&gt;readPdo instanceof Closure) &#123;</span><br><span class="line">        return $this-&gt;readPdo = call_user_func($this-&gt;readPdo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $this-&gt;readPdo ?: $this-&gt;getPdo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、-进阶-关系模型"><a href="#五、-进阶-关系模型" class="headerlink" title="五、 进阶 - 关系模型"></a>五、 进阶 - 关系模型</h1><p>关于关系模型的定义，其操作接口全部定义在Illuminate\Database\Eloquent\Concerns\HasRelationships::trait中。每个关系定义方法，都是对一个关系对象的定义。</p>
<h2 id="5-1-关系对象"><a href="#5-1-关系对象" class="headerlink" title="5.1 关系对象"></a>5.1 关系对象</h2><p>关系对象全部继承自 <code>Illuminate\Database\Eloquent\Relations\Relation::abstract</code> 虚拟类。关系对象由一个查询构造器组成，用来保存由关系定义所决定的关系查询条件，和加载关系时的额外条件。比如一对一（多）的关系定义中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public function addConstraints()</span><br><span class="line">&#123;</span><br><span class="line">    if (static::$constraints) &#123;</span><br><span class="line">        $this-&gt;query-&gt;where($this-&gt;foreignKey, &apos;=&apos;, $this-&gt;getParentKey());</span><br><span class="line"></span><br><span class="line">        $this-&gt;query-&gt;whereNotNull($this-&gt;foreignKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当需要获取关系数据时，都会实例化关系对象，实例化的过程中调用addConstraints方法。与此同时，在加载关系数据时，可以传入额外的查询条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$users = App\User::with([&apos;posts&apos; =&gt; function ($query) &#123;</span><br><span class="line">    $query-&gt;where(&apos;title&apos;, &apos;like&apos;, &apos;%first%&apos;);</span><br><span class="line">&#125;])-&gt;get();</span><br></pre></td></tr></table></figure>
<p>这些条件最终都会保存在关系对象的查询构造器中，在获取关系数据时，起到筛选作用。</p>
<p>在使用关系模型时，有两种模式：一种是即时加载模式，一种是预加载模式。</p>
<h2 id="5-2-即时加载"><a href="#5-2-即时加载" class="headerlink" title="5.2 即时加载"></a>5.2 即时加载</h2><p>即时加载关系对象，是基于当前模型对象来获取关系数据。当以<code>$user-&gt;post</code>的形式获取Model关系属性时，通过__get方法触发对关系模型的获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public function getAttribute($key)</span><br><span class="line">&#123;</span><br><span class="line">    if (! $key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 访问对象属性或存取器</span><br><span class="line">    if (array_key_exists($key, $this-&gt;attributes) ||</span><br><span class="line">        $this-&gt;hasGetMutator($key)) &#123;</span><br><span class="line">        return $this-&gt;getAttributeValue($key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断同名方法是否存在</span><br><span class="line">    if (method_exists(self::class, $key)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取关系对象</span><br><span class="line">    return $this-&gt;getRelationValue($key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取关系模型并实例化，得到关系模型对象，执行关系模型对象的addConstraints方法，将模型对象，转化为关系模型对象的查询条件：</p>
<ul>
<li>已知模型对象</li>
<li>关系定义绑定对象的模型名称</li>
<li>关系定义外键，已知模型对象的主键，及主键的值<br>通过上述三个条件，可以生成关系查询，并获取到结果，这个过程是即时加载关系数据的。</li>
</ul>
<p>即时加载在只有单个模型对象时比较适用，如果我们拥有的是一个模型集合，并且需要用到关系数据时，通过即时加载的模式，会有N+1的问题。针对每个模型去获取关系数据，都要进行一次数据库查询，这种情况下，就需要使用预加载的模式。</p>
<h2 id="5-3-预加载"><a href="#5-3-预加载" class="headerlink" title="5.3 预加载"></a>5.3 预加载</h2><p>对于预加载关系的情况，Model::with(‘relation’)标记关系为预加载，在Model::get()获取数据时，检查到对关系的预加载标记，会对关系进行实例化，这个实例化的过程，会通过Relation::noConstraints屏蔽对关系数据的直接加载，在后续过程中，由通过Model::get()获取的模型列表数据，得到模型的ID列表，关系利用这个ID列表，统一查询关系模型数据。查询完成之后匹配到对应的模型中去，其过程如下：</p>
<ul>
<li>EloquentBuilder::get():<ul>
<li>Builder::get() 获取到模型数据列表</li>
<li>EloquentBuilder::eagerLoadRelations(): 获取所有模型关系<ul>
<li>foreach relations EloquentBuilder::eagerLoadRelation() 针对每个关系获取关系数据</li>
</ul>
</li>
<li>Collection: 转化为集合</li>
</ul>
</li>
</ul>
<p>其中：eagerLoadRelation()的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Illuminate\Database\Eloquent\Builder::eagerLoadRelation()</span><br><span class="line">protected function eagerLoadRelation(array $models, $name, Closure $constraints)</span><br><span class="line">&#123;</span><br><span class="line">    // 获取关系对象，这里获取关系对象时会通过Relation::noConstraints屏蔽即时加载</span><br><span class="line">    $relation = $this-&gt;getRelation($name);</span><br><span class="line"></span><br><span class="line">    // 在这里将模型id列表注入到关系对象中，作为关系模型查询的条件</span><br><span class="line">    $relation-&gt;addEagerConstraints($models);</span><br><span class="line"></span><br><span class="line">    // 这里可以注入Model::with([&apos;relation&apos; =&gt; function($query)&#123;&#125;])时定义的关系额外条件</span><br><span class="line">    $constraints($relation);</span><br><span class="line"></span><br><span class="line">    // 匹配每个关系对象数据到模型对象中去</span><br><span class="line">    return $relation-&gt;match(</span><br><span class="line">        $relation-&gt;initRelation($models, $name),</span><br><span class="line">        $relation-&gt;getEager(), $name</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h1><p>理解laravel的Eloquent ORM模型，可以先建立下列对象的概念：</p>
<ul>
<li>Model，模型对象，编码中比较容易接触与使用的对象，是框架开放给用户的最直观的操作接口;</li>
<li>EloquentBuilder，Eloquent查询构造器;</li>
<li>Builder，数据库查询构造器，是EloquentBuilder的组成部分;</li>
<li>connection，数据库连接对象，与数据库进行交互，执行查询构造器描述的SQL语句;</li>
<li>Grammar，语法解析器，将查询构造器的描述解释为规范的SQL语句;</li>
<li>Processor，转发查询进程的结果数据;</li>
<li>Relation，关系对象，描述两个模型之间的关系，关键是关系之间的查询条件;</li>
<li>JoinClause，连接查询对象，多表join查询的实现;</li>
</ul>
<p>上述对象的关系如图所示 <img src="/images/Laravel-Model.png" alt="relateion"></p>
<p>当然，Eloquent ORM还有其他跟多的特性，比如数据迁移、数据填充、查询作用域、存取器等，可以留给读者自行去了解与熟悉。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20190801/laravel/queue.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20190801/laravel/queue.html" itemprop="url">laravel 队列部分源码阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-01T09:30:00+08:00">
                2019-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、-依赖的服务"><a href="#一、-依赖的服务" class="headerlink" title="一、 依赖的服务"></a>一、 依赖的服务</h1><h2 id="Illuminate-Queue-QueueServiceProvider"><a href="#Illuminate-Queue-QueueServiceProvider" class="headerlink" title="Illuminate\Queue\QueueServiceProvider"></a>Illuminate\Queue\QueueServiceProvider</h2><p>队列服务由服务提供者QueueServiceProvider注册。</p>
<ul>
<li>registerManager() 注册队列管理器，同时添加 Null/Sync/Database/Redis/Beanstalkd/Sqs 连接驱动<ul>
<li>Null：不启动队列，生产者产生的任务被丢弃</li>
<li>Sync：同步队列，生产者产生的任务直接执行</li>
<li>Database：数据库队列驱动，生产者产生的任务放入数据库</li>
<li>Redis：Redis队列驱动，生产者产生的任务放入Redis</li>
<li>Beanstalkd：略过</li>
<li>Sqs：略过</li>
</ul>
</li>
<li>registerConnection() 注册队列连接获取闭包，当需要用到队列驱动连接时，实例化连接</li>
<li>registerWorker() 注册队列消费者</li>
<li>registerListener() Listen模式注册队列消费者</li>
<li>registerFailedJobServices() 注册失败任务服务</li>
</ul>
<table>
<thead>
<tr>
<th>注册方法</th>
<th>对象</th>
<th>别名</th>
</tr>
</thead>
<tbody>
<tr>
<td>QueueServiceProvider::registerManager()</td>
<td>\Illuminate\Queue\QueueManager::class</td>
<td>queue</td>
</tr>
<tr>
<td>QueueServiceProvider::registerConnection()</td>
<td>\Illuminate\Queue\Queue::class</td>
<td>queue.connection</td>
</tr>
<tr>
<td>QueueServiceProvider::registerWorker()</td>
<td>\Illuminate\Queue\Worker::class</td>
<td>queue.worker</td>
</tr>
<tr>
<td>QueueServiceProvider::registerListener()</td>
<td>\Illuminate\Queue\Listener::class</td>
<td>queue.listener</td>
</tr>
<tr>
<td>QueueServiceProvider::registerFailedJobServices()</td>
<td>\Illuminate\Queue\Failed\FailedJobProviderInterface::class</td>
<td>queue.failer</td>
</tr>
</tbody>
</table>
<h2 id="Illuminate-Bus-BusServiceProvider"><a href="#Illuminate-Bus-BusServiceProvider" class="headerlink" title="Illuminate\Bus\BusServiceProvider"></a>Illuminate\Bus\BusServiceProvider</h2><p>这个服务提供者注册了Dispatcher这个服务，可以将具体的任务派发到队列。</p>
<h1 id="二、-任务机制"><a href="#二、-任务机制" class="headerlink" title="二、 任务机制"></a>二、 任务机制</h1><p>一个可放入队列的任务类：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Bus</span>\<span class="title">Queueable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">SerializesModels</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">InteractsWithQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Queue</span>\<span class="title">ShouldQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Bus</span>\<span class="title">Dispatchable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">ShouldQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">InteractsWithQueue</span>, <span class="title">Queueable</span>, <span class="title">SerializesModels</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>任务在队列中需要经过两个过程：一个是任务入队，就是将要执行的任务，放到队列中去的过程，所有会发生这一过程的业务、对象、调用等等，可以统称为生产者；与之对应的，将任务从队列中取出，并执行的过程，叫做任务出队，所有会发生这一过程的业务、对象、调用等等，可以统称为消费者。</p>
<h2 id="2-1-任务的要素"><a href="#2-1-任务的要素" class="headerlink" title="2.1 任务的要素"></a>2.1 任务的要素</h2><h3 id="2-1-1-Illuminate-Foundation-Bus-Dispatchable"><a href="#2-1-1-Illuminate-Foundation-Bus-Dispatchable" class="headerlink" title="2.1.1 Illuminate\Foundation\Bus\Dispatchable"></a>2.1.1 Illuminate\Foundation\Bus\Dispatchable</h3><p>这个trait给任务添加了两个静态方法<code>dispatch/withChain</code>，赋予了任务派发的接口。</p>
<ol>
<li><code>dispatch</code></li>
</ol>
<p>dispatch方法触发任务指派动作。当执行 <code>Job::dispatch()</code>时，会实例化一个<code>Illuminate\Foundation\Bus\PendingDispatch</code>对象<code>PendingDispatch</code>，并且将任务调用类实例化后的对象<code>job</code>当作构造函数的参数：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illuminate\Foundation\Bus\Dispatchable::trait</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里的static转发到实际执行dispath的类 Job::dispatch，也就是Job类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PendingDispatch(<span class="keyword">new</span> <span class="keyword">static</span>(...func_get_args()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PendingDispatch</code>对象接下来可以通过链式调用来指定队列相关信息 <code>onConnection/onQueue/allOnConnection/allOnQueue/delay/chain</code>，然后在析构函数中，做实际的派发动作：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illuminate\Foundation\Bus\PendingDispatch::class</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Illuminate\Contracts\Bus\Dispatcher</span></span><br><span class="line">    <span class="comment">// 这个服务由Illuminate\Bus\BusServiceProvider注册</span></span><br><span class="line">    app(Dispatcher::class)-&gt;dispatch(<span class="keyword">$this</span>-&gt;job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PendingDispath</code>这个中间指派者的作用，就是引出这里从容器中解析出来的服务<code>Dispatcher::class</code>，真正的任务指派者<code>Dispatcher</code>。</p>
<ol>
<li><code>withChain</code></li>
</ol>
<p>withChain用于指定应该按顺序运行的队列列表。它只是一个语法糖，实际上的效果等同于：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. withChain的用法</span></span><br><span class="line">Job::withChain([</span><br><span class="line">    <span class="keyword">new</span> OptimizePodcast,</span><br><span class="line">    <span class="keyword">new</span> ReleasePodcast</span><br><span class="line">])-&gt;dispatch();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 等同于dispatch的用法</span></span><br><span class="line">Job::dispatch()-&gt;chain([</span><br><span class="line">    <span class="keyword">new</span> OptimizePodcast,</span><br><span class="line">    <span class="keyword">new</span> ReleasePodcast</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<h3 id="2-1-2-Illuminate-Bus-Queueable"><a href="#2-1-2-Illuminate-Bus-Queueable" class="headerlink" title="2.1.2 Illuminate\Bus\Queueable"></a>2.1.2 Illuminate\Bus\Queueable</h3><p>上文提到的<code>PendingDispath</code>，可以指定队列信息的方法，都是转发到任务对应的方法进行调用，Queueable就是实现了这部分的功能。这部分包括以下接口：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onConnection</td>
<td>指定连接名</td>
</tr>
<tr>
<td>onQueue</td>
<td>指定队列名</td>
</tr>
<tr>
<td>allOnConnection</td>
<td>指定工作链的连接名</td>
</tr>
<tr>
<td>allOnQueue</td>
<td>指定工作链的队列名</td>
</tr>
<tr>
<td>delay</td>
<td>设置延迟执行时间</td>
</tr>
<tr>
<td>chain</td>
<td>指定工作链</td>
</tr>
</tbody>
</table>
<p>以及最后一个方法<code>dispatchNextJobInChain</code>。上述方法都是在任务执行前调用，设置任务相关参数。<code>dispatchNextJobInChain</code>是在任务执行期间，如果检查到任务定义了工作链，就会派发工作链上面的任务到队列中。</p>
<h3 id="2-1-3-Illuminate-Queue-SerializesModels"><a href="#2-1-3-Illuminate-Queue-SerializesModels" class="headerlink" title="2.1.3 Illuminate\Queue\SerializesModels"></a>2.1.3 Illuminate\Queue\SerializesModels</h3><p>这个trait的作用是字符串化任务信息，方便将任务信息保存到数据库或Redis等存储器中，然后在队列的消费端取出任务信息，并据此重新实例化为任务对象，便于执行任务。</p>
<h3 id="2-1-4-Illuminate-Queue-InteractsWithQueue"><a href="#2-1-4-Illuminate-Queue-InteractsWithQueue" class="headerlink" title="2.1.4 Illuminate\Queue\InteractsWithQueue"></a>2.1.4 Illuminate\Queue\InteractsWithQueue</h3><p>这个trait赋予了任务与队列进行数据交互的能力。InteractsWithQueue是任务的必要组成，如果一个任务只能被执行，而不能与队列进行交互，那么这个任务在队列中的状态就是未知的，必然会造成混乱。InteractsWithQueue与队列的交互能力来源于$job属性，它是一个QueueJob实例，需要与任务的概念进行区别：任务是泛指可执行的对象，而这个$job，是在任务出队以后，解析出来的QueueJob对象。</p>
<p>即时一个任务类实现了InteractsWithQueue，它在实例化的时候并没有$job这个属性。需要等到出队后的执行过程中，这个$job才被手动设置给任务。</p>
<h3 id="2-1-5-Illuminate-Contracts-Queue-ShouldQueue"><a href="#2-1-5-Illuminate-Contracts-Queue-ShouldQueue" class="headerlink" title="2.1.5 Illuminate\Contracts\Queue\ShouldQueue"></a>2.1.5 Illuminate\Contracts\Queue\ShouldQueue</h3><p>ShouldQueue也是是任务的必要实现的接口。只有实现了ShouldQueue接口的任务，才可以被放入队列。上文所提到的真正的任务指派者<code>Dispatcher</code>，它在<code>PendingDispath</code>销毁时所执行的<code>dispatch</code>方法代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illuminate\Bus\Dispatcher::class</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查任务指派者是否注入了队列服务</span></span><br><span class="line">    <span class="comment">// 并且当前任务需要方法队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;queueResolver &amp;&amp; <span class="keyword">$this</span>-&gt;commandShouldBeQueued($command)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;dispatchToQueue($command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;dispatchNow($command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>commandShouldBeQueued</code>方法的作用就是检查任务对象是否实现了ShouldQueue接口。如果是，就是执行dispatchToQueue方法，将任务放入队列之中；否则执行dispatchNow，放入队列执行栈（pipeline），进行同步执行。</p>
<h2 id="2-2-任务入队"><a href="#2-2-任务入队" class="headerlink" title="2.2 任务入队"></a>2.2 任务入队</h2><p>任务是如何被放入队列中的呢？这就引出了payload这个概念。当Dispatcher这个服务通过dispatch方法派发任务时，会通过队列服务，将任务push到队列中，在push的过程中会执行createPayloadArray方法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illuminate\Queue\Queue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createPayloadArray</span><span class="params">($job, $data = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果我们文中所提到的“任务”，是一个对象的话，会调用createObjectPayload方法</span></span><br><span class="line">    <span class="comment">// 进行一次封装，将封装后的数据Payload存入队列，如果不是一个对象的话，调用</span></span><br><span class="line">    <span class="comment">// createStringPayload进行一次封装，然后存入队列</span></span><br><span class="line">    <span class="keyword">return</span> is_object($job)</span><br><span class="line">                ? <span class="keyword">$this</span>-&gt;createObjectPayload($job)</span><br><span class="line">                : <span class="keyword">$this</span>-&gt;createStringPayload($job, $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createObjectPayload</span><span class="params">($job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'displayName'</span> =&gt; <span class="keyword">$this</span>-&gt;getDisplayName($job),</span><br><span class="line">        <span class="string">'job'</span> =&gt; <span class="string">'Illuminate\Queue\CallQueuedHandler@call'</span>,</span><br><span class="line">        <span class="string">'maxTries'</span> =&gt; $job-&gt;tries ?? <span class="keyword">null</span>,</span><br><span class="line">        <span class="string">'timeout'</span> =&gt; $job-&gt;timeout ?? <span class="keyword">null</span>,</span><br><span class="line">        <span class="string">'timeoutAt'</span> =&gt; <span class="keyword">$this</span>-&gt;getJobExpiration($job),</span><br><span class="line">        <span class="string">'data'</span> =&gt; [</span><br><span class="line">            <span class="string">'commandName'</span> =&gt; get_class($job),</span><br><span class="line">            <span class="string">'command'</span> =&gt; serialize(<span class="keyword">clone</span> $job),</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createStringPayload</span><span class="params">($job, $data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'displayName'</span> =&gt; is_string($job) ? explode(<span class="string">'@'</span>, $job)[<span class="number">0</span>] : <span class="keyword">null</span>,</span><br><span class="line">        <span class="string">'job'</span> =&gt; $job, <span class="string">'maxTries'</span> =&gt; <span class="keyword">null</span>,</span><br><span class="line">        <span class="string">'timeout'</span> =&gt; <span class="keyword">null</span>, <span class="string">'data'</span> =&gt; $data,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>createObjectPayload/createStringPayload</code> 这两个方法return的数组就是payload，是便于存储的一种格式。请特别注意 <code>Illuminate\Queue\CallQueuedHandler@call</code> 这部分出现的CallQueuedHandler这个对象，他是任务机制中的重要一环。</p>
<h2 id="2-3-任务出队"><a href="#2-3-任务出队" class="headerlink" title="2.3 任务出队"></a>2.3 任务出队</h2><p>任务出队是建立在消费者开始工作的基础之上的。在laravel的应用中，一类消费者就是Worker，队列处理器。通过命令行<code>php artisan queue:work</code>来启动一个Worker。Worker在daemon模式下，会不断的尝试从队列中取出任务并执行，这一过程有以下执行环节：</p>
<ul>
<li>第一步：检查是否要暂停队列，是则暂停一段时间，否则经行下一步</li>
<li>第二步：取出当前要执行的任务，并给任务设置一个超时进程，</li>
<li>第三步：执行任务，如果当前没有任务，暂停一段时间</li>
<li>第四步：检查是否要停止队列</li>
</ul>
<p>遇到三种情况会停止队列：</p>
<ul>
<li>Worker进程收到SIGTERM信号</li>
<li>使用内存超过限制</li>
<li>收到重启命令</li>
</ul>
<p>第二步就是任务出队的过程。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法表示，从连接$connection中，名称为$queue的队列中取出下一个任务。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getNextJob</span><span class="params">($connection, $queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (explode(<span class="string">','</span>, $queue) <span class="keyword">as</span> $queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! is_null($job = $connection-&gt;pop($queue))) &#123;</span><br><span class="line">                <span class="keyword">return</span> $job;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;exceptions-&gt;report($e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;stopWorkerIfLostConnection($e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;exceptions-&gt;report($e = <span class="keyword">new</span> FatalThrowableError($e));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;stopWorkerIfLostConnection($e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果队列驱动使用的时Database，那么$connection指的就是Illuminate\Queue\DatabaseQueue的实例，如果队列驱动使用的时Redis，那么$connection指的就是Illuminate\Queue\RedisQueue的实例。</p>
<p>$connection的pop方法会从队列存储中取出下一个payload，经过队列驱动的转化，得到不同的QueueJob实例，也就是上文提到的$job对象，调用$job的fire方法，任务就开始执行。</p>
<h2 id="2-4-任务执行-CallQueuedHandler"><a href="#2-4-任务执行-CallQueuedHandler" class="headerlink" title="2.4 任务执行 - CallQueuedHandler"></a>2.4 任务执行 - CallQueuedHandler</h2><p>CallQueuedHandler就像是队列这个轨道上的一辆车，是任务机制中的重要环节。</p>
<p>我们可以把入队与出队称为队列的“内部操作”，他们是属于Queue这个概念之内的问题。而CallQueuedHandler可以看成Queue与外部任务对接的“标准接口”，如果把所有要执行的任务称为“可执行对象”，那么，只需要用CallQueueHandle这个对象来装载“可执行对象”，就可以让这个“可执行对象”利用队列的机制来执行。</p>
<p>在入队时，CallQueueHandle与“可执行对象”组合成为payload。在出队时，payload重放成为QueueJob，QueueJob调用fire的下一个环节，就是CallQueueHandle。</p>
<h3 id="2-4-1-CallQueuedHandler的作用"><a href="#2-4-1-CallQueuedHandler的作用" class="headerlink" title="2.4.1 CallQueuedHandler的作用"></a>2.4.1 CallQueuedHandler的作用</h3><p>在入队与出队的过程中，CallQueuedHandler并不发生任何作用，他只是随payload在队列的存储中流转进出。当任务被取出执行时，CallQueuedHandler就开始发挥作用。CallQueuedHandler的作用可以归纳为两点：</p>
<ul>
<li>继承QueueJob调用的fire方法，转发到CallQueuedHandler的handle方法，然后启动任务的执行方法。</li>
<li>处理任务执行结果与队列中数据（payload）的去留关系</li>
</ul>
<h3 id="2-4-2-任务执行的调用栈"><a href="#2-4-2-任务执行的调用栈" class="headerlink" title="2.4.2 任务执行的调用栈"></a>2.4.2 任务执行的调用栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueJob::fire() -&gt;  CallQueuedHandler::handle() -&gt;  [任务或其他可执行对象调用]</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker-&gt;process()  消费者执行一个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">($connectionName, $job, WorkerOptions $options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;raiseBeforeJobEvent($connectionName, $job);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;markJobAsFailedIfAlreadyExceedsMaxAttempts(</span><br><span class="line">            $connectionName, $job, (int) $options-&gt;maxTries</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        $job-&gt;fire();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;raiseAfterJobEvent($connectionName, $job);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handleJobException($connectionName, $job, $options, $e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;handleJobException(</span><br><span class="line">            $connectionName, $job, $options, <span class="keyword">new</span> FatalThrowableError($e)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job-&gt;fire()</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $payload = <span class="keyword">$this</span>-&gt;payload();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析队列任务信息，查看上文中的createPayload方法：  $payload = ['job' =&gt; 'Illuminate\Queue\CallQueuedHandler@call']</span></span><br><span class="line">    <span class="comment">// 所以这里$class = Illuminate\Queue\CallQueuedHandler, $method = call</span></span><br><span class="line">    <span class="keyword">list</span>($class, $method) = JobName::parse($payload[<span class="string">'job'</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果payload是通过CallQueuedHandler进行包装的，那么此时instance就是CallQueuedHandler的实例，method就是call方法</span></span><br><span class="line">    <span class="comment">// 如果payload是通过字符串进行包装的，那么此时的instance就是制定的任务对象，method就是制定的调用方法</span></span><br><span class="line">    (<span class="keyword">$this</span>-&gt;instance = <span class="keyword">$this</span>-&gt;resolve($class))-&gt;&#123;$method&#125;(<span class="keyword">$this</span>, $payload[<span class="string">'data'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>laravel提供的队里机制的执行调用栈，就是上述过程。当我们指队列的任务机制时，包含的内容有以下两点：</p>
<ul>
<li>队列底层提供的入队与出队机制</li>
<li>任务出队后的执行调用栈</li>
</ul>
<h1 id="三、-事件机制"><a href="#三、-事件机制" class="headerlink" title="三、 事件机制"></a>三、 事件机制</h1><p>在充分理解任务机制的前提下，事件机制就很好理解了。事件监听器的原理是，通过Illuminate\Events\CallQueuedListener 来作为一个特殊的“任务”，将事件绑定与监听信息保存到这个“任务”中，当事件被触发时，通过事件解析出与之对应的“任务”，然后对这个“任务”进行派发，执行这个“任务”时，再去执行事件监听器。所以，这个环节的重点其实是，事件、监听器、CallQueuedListener三者之间是如何进行关联的，也就是事件监听机制。所以我们后面在分析laravel事件机制相关源码时，遇到CallQueuedListener这个对象时就知道，这是要开始与队列进行对接了。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 触发一个事件</span></span><br><span class="line">event(<span class="keyword">new</span> Event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从触发事件到进入队列的过程形容如下</span></span><br><span class="line">$eventCommand = <span class="keyword">new</span> \Illuminate\Events\CallQueuedListener(<span class="keyword">new</span> Event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PendingDispatch($eventCommand);</span><br></pre></td></tr></table></figure>
<h1 id="四、-消息机制-Notification"><a href="#四、-消息机制-Notification" class="headerlink" title="四、 消息机制 Notification"></a>四、 消息机制 Notification</h1><p>消息机制的实现与事件机制类似。通过Illuminate\Notifications\SendQueuedNotifications 来作为一个特殊的“任务”，与消息相关信息进行关联，通过SendQueuedNotifications对象来完成入队与出队相关过程，然后在执行“任务”SendQueuedNotifications的时候解析出关联的notifiables和notification，然后据此执行消息相关逻辑。</p>
<h1 id="五、-手动入队"><a href="#五、-手动入队" class="headerlink" title="五、 手动入队"></a>五、 手动入队</h1><p>上面提到的都是系统提供的队列机制，除此之外，你还可以手动推送任务到队列，即通过Queue Facade来指派任务。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyTask</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">ShouldQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">InteractsWithQueue</span>, <span class="title">Queueable</span>, <span class="title">SerializesModels</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($job, $args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"MyTask"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送至队列</span></span><br><span class="line">Queue::push(<span class="string">'MyTask@handle'</span>, $args, $queueName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyAnotherTask</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnotherTask</span> <span class="keyword">implements</span> <span class="title">ShouldQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">InteractsWithQueue</span>, <span class="title">Queueable</span>, <span class="title">SerializesModels</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"MyTask"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送至队列</span></span><br><span class="line">Queue::push(<span class="keyword">new</span> MyAnotherTask, $args, $queueName);</span><br></pre></td></tr></table></figure></p>
<h2 id="5-1-入队对象是一个实例"><a href="#5-1-入队对象是一个实例" class="headerlink" title="5.1 入队对象是一个实例"></a>5.1 入队对象是一个实例</h2><p>通过实例的方式，将任务推送到队列中，在createPayload的环节，执行的是createObjectPayload方法，这时可以利用系统提供的队列机制，实例只需要有一个handle方法作为执行方法，来承接CallQueuedHandler::handle()传递的调用栈。此时，handle方法只需要业务本身涉及到的数据作为参数。</p>
<h2 id="5-2-入队对象是一个字符串"><a href="#5-2-入队对象是一个字符串" class="headerlink" title="5.2 入队对象是一个字符串"></a>5.2 入队对象是一个字符串</h2><p>通过字符串的方式，将任务推送到队列中，在createPayload的环节，执行的是createStringPayload方法，这时无法利用系统体统的队列机制中的第二层内容：执行调用栈，在QueueJob::fire()之后会调用字符串指定的对象及方法。此时，方法除了需要业务本身涉及的数据作为参数外，还需要任务重放得到的QueueJob对象，作为第一个参数，所以上面代码中两个自定义任务的函数签名是不同的。</p>
<p>如果仅仅通过上述代码来执行的话，<code>MyAnotherTask</code>这个任务可能会一直执行下去，原因是缺少对执行任务后的处理：如果任务执行成功，因该从队列中删除掉；如果执行失败，也要有对应的处理措施。也就是CallQueuedHandler的第二个作用。我们不妨来看看CallQueuedHandler，是如何来处理这个问题的。</p>
<p>无论是系统的任务机制，或是事件机制，消费端从队列中取出任务信息后，还原出一个Job对象（RedisJob/DatabaseJob），然后执行这个Job的fire方法时，都会借助CallQueuedHandler这个对象来执行任务的具体内容：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallQueuedHandler-&gt;call()</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">call</span><span class="params">(Job $job, array $data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 预处理任务信息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        $command = <span class="keyword">$this</span>-&gt;setJobInstanceIfNecessary(</span><br><span class="line">            $job, unserialize($data[<span class="string">'command'</span>])</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ModelNotFoundException $e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;handleModelNotFound($job, $e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过dispatcher同步执行任务</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;dispatcher-&gt;dispatchNow(</span><br><span class="line">        $command, <span class="keyword">$this</span>-&gt;resolveHandler($job, $command)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务未失败，且未释放，确保工作链上的任务都已派发</span></span><br><span class="line">    <span class="keyword">if</span> (!$job-&gt;hasFailed() &amp;&amp; !$job-&gt;isReleased()) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;ensureNextJobInChainIsDispatched($command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务未删除或未释放，删除任务</span></span><br><span class="line">    <span class="keyword">if</span> (!$job-&gt;isDeletedOrReleased()) &#123;</span><br><span class="line">        $job-&gt;delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，如果通过字符串的方式，手动派发任务到队列，需要自己手动进行像CallQueuedHandler::call()方法中那样的收尾工作，使任务执行完毕后，清除任务存储在队列中的信息，避免任务被重新执行。</p>
<h1 id="六、-payload的存储"><a href="#六、-payload的存储" class="headerlink" title="六、 payload的存储"></a>六、 payload的存储</h1><p>常用的数据存储驱动是Database与Redis，我们以Redis作为例子来做说明。</p>
<h2 id="6-1-Redis"><a href="#6-1-Redis" class="headerlink" title="6.1 Redis"></a>6.1 Redis</h2><p>假设我们现在设置有一个名叫queue的队列，那么，在队列执行的过程中，会有下列几个key被redis用到：</p>
<ul>
<li>queue 任务信息默认存储的key</li>
<li>queue:reserved 任务执行过程中，临时存储的key</li>
<li>queue:delayed 任务执行失败，被重新发布到的key，或者延迟执行的任务被发布到的key</li>
</ul>
<h3 id="6-1-1-入队"><a href="#6-1-1-入队" class="headerlink" title="6.1.1 入队"></a>6.1.1 入队</h3><p>任务信息被推入队列时，调用RedisQueue的push方法，将任务信息的载体payload，rpush到键名为queue的lists中：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a new job onto the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  object|string  $job</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  mixed   $data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">($job, $data = <span class="string">''</span>, $queue = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;pushRaw(<span class="keyword">$this</span>-&gt;createPayload($job, $data), $queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a raw payload onto the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $payload</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array   $options</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pushRaw</span><span class="params">($payload, $queue = null, array $options = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;getConnection()-&gt;rpush(<span class="keyword">$this</span>-&gt;getQueue($queue), $payload);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json_decode($payload, <span class="keyword">true</span>)[<span class="string">'id'</span>] ?? <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是将一个任务推入队列中延迟执行，调用的是RedisQueue的later方法，zadd到键名为queue:delayed的zset中，延迟时长作为排序的依据：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a new job onto the queue after a delay.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  \DateTimeInterface|\DateInterval|int  $delay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  object|string  $job</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  mixed   $data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">later</span><span class="params">($delay, $job, $data = <span class="string">''</span>, $queue = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;laterRaw($delay, <span class="keyword">$this</span>-&gt;createPayload($job, $data), $queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a raw job onto the queue after a delay.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  \DateTimeInterface|\DateInterval|int  $delay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $payload</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">laterRaw</span><span class="params">($delay, $payload, $queue = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;getConnection()-&gt;zadd(</span><br><span class="line">        <span class="keyword">$this</span>-&gt;getQueue($queue).<span class="string">':delayed'</span>, <span class="keyword">$this</span>-&gt;availableAt($delay), $payload</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> json_decode($payload, <span class="keyword">true</span>)[<span class="string">'id'</span>] ?? <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-2-出队"><a href="#6-1-2-出队" class="headerlink" title="6.1.2 出队"></a>6.1.2 出队</h3><p>出队的方法只有一个，就是RedisQueue的pop方法。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pop the next job off of the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Contracts\Queue\Job|null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pop</span><span class="params">($queue = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;migrate($prefixed = <span class="keyword">$this</span>-&gt;getQueue($queue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">list</span>($job, $reserved) = <span class="keyword">$this</span>-&gt;retrieveNextJob($prefixed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($reserved) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisJob(</span><br><span class="line">            <span class="keyword">$this</span>-&gt;container, <span class="keyword">$this</span>, $job,</span><br><span class="line">            $reserved, <span class="keyword">$this</span>-&gt;connectionName, $queue ?: <span class="keyword">$this</span>-&gt;default</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Migrate any delayed or expired jobs onto the primary queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">migrate</span><span class="params">($queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;migrateExpiredJobs($queue.<span class="string">':delayed'</span>, $queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! is_null(<span class="keyword">$this</span>-&gt;retryAfter)) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;migrateExpiredJobs($queue.<span class="string">':reserved'</span>, $queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Migrate the delayed jobs that are ready to the regular queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">migrateExpiredJobs</span><span class="params">($from, $to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getConnection()-&gt;eval(</span><br><span class="line">        LuaScripts::migrateExpiredJobs(), <span class="number">2</span>, $from, $to, <span class="keyword">$this</span>-&gt;currentTime()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在出队之前，先检查queue:delayed上是否有到期的任务，有的话，先将这部分任务的信息转移到queue上，如果设置有超时时间，还会检查queue:reserved上是否有到期的任务，将这部分的任务信息也转移到queue上。</p>
<p>接着通过retrieveNextJob方法获取下一个要执行的任务信息：从queue中取出第一个任务，将他的attempt值加一后放入到queue:reserved中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve the next job from the queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">retrieveNextJob</span><span class="params">($queue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getConnection()-&gt;eval(</span><br><span class="line">            LuaScripts::pop(), <span class="number">2</span>, $queue, $queue.<span class="string">':reserved'</span>,</span><br><span class="line">            <span class="keyword">$this</span>-&gt;availableAt(<span class="keyword">$this</span>-&gt;retryAfter)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// LuaScripts::pop</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the Lua script for popping the next job off of the queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * KEYS[1] - The queue to pop jobs from, for example: queues:foo</span></span><br><span class="line"><span class="comment">     * KEYS[2] - The queue to place reserved jobs on, for example: queues:foo:reserved</span></span><br><span class="line"><span class="comment">     * ARGV[1] - The time at which the reserved job will expire</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&lt;&lt;&lt;'LUA'</span></span><br><span class="line"><span class="string">-- Pop the first job off of the queue...</span></span><br><span class="line"><span class="string">local job = redis.call('lpop', KEYS[1])</span></span><br><span class="line"><span class="string">local reserved = false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if(job ~= false) then</span></span><br><span class="line"><span class="string">    -- Increment the attempt count and place job on the reserved queue...</span></span><br><span class="line"><span class="string">    reserved = cjson.decode(job)</span></span><br><span class="line"><span class="string">    reserved['attempts'] = reserved['attempts'] + 1</span></span><br><span class="line"><span class="string">    reserved = cjson.encode(reserved)</span></span><br><span class="line"><span class="string">    redis.call('zadd', KEYS[2], ARGV[1], reserved)</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;job, reserved&#125;</span><br><span class="line">LUA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-执行结果"><a href="#6-1-3-执行结果" class="headerlink" title="6.1.3 执行结果"></a>6.1.3 执行结果</h3><p>在任务执行成功时，检查任务是否被删除或Release，如果没有的话，就从queue:reserved中删除任务信息；如果执行失败的话，检查是否超过最大执行次数，超过则删除任务信息，否则标记为已删除，从queue:reserved中删除任务信息，并重新发布任务到queue:delayed中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delete a reserved job from the reserved queue and release it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  \Illuminate\Queue\Jobs\RedisJob  $job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  int  $delay</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteAndRelease</span><span class="params">($queue, $job, $delay)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $queue = <span class="keyword">$this</span>-&gt;getQueue($queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;getConnection()-&gt;eval(</span><br><span class="line">            LuaScripts::release(), <span class="number">2</span>, $queue.<span class="string">':delayed'</span>, $queue.<span class="string">':reserved'</span>,</span><br><span class="line">            $job-&gt;getReservedJob(), <span class="keyword">$this</span>-&gt;availableAt($delay)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// LuaScripts::release()</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the Lua script for releasing reserved jobs.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * KEYS[1] - The "delayed" queue we release jobs onto, for example: queues:foo:delayed</span></span><br><span class="line"><span class="comment">     * KEYS[2] - The queue the jobs are currently on, for example: queues:foo:reserved</span></span><br><span class="line"><span class="comment">     * ARGV[1] - The raw payload of the job to add to the "delayed" queue</span></span><br><span class="line"><span class="comment">     * ARGV[2] - The UNIX timestamp at which the job should become available</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&lt;&lt;&lt;'LUA'</span></span><br><span class="line"><span class="string">-- Remove the job from the current queue...</span></span><br><span class="line"><span class="string">redis.call('zrem', KEYS[2], ARGV[1])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- Add the job onto the "delayed" queue...</span></span><br><span class="line"><span class="string">redis.call('zadd', KEYS[1], ARGV[2], ARGV[1])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return true</span></span><br><span class="line"><span class="string">LUA;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-Database"><a href="#6-2-Database" class="headerlink" title="6.2 Database"></a>6.2 Database</h2><p>如果队列驱动是数据库，这个过程也基本一致，不过只需要用一张数据表来保存任务信息，用reserved_at，available_at两个字段来表示不同的任务状态，在取出任务及任务失败等复杂情况下，通过事务来保证任务执行的结果与数据的一致性。：</p>
<ul>
<li>给reserved_at字段赋值，对应Redis中push到queue:reserved</li>
<li>给available_at字段赋值，对应Redis中push到queue:delayed</li>
<li>Redis中LuaScripts脚本部分的执行，对应数据库中的事务</li>
</ul>
<h1 id="七、-总结"><a href="#七、-总结" class="headerlink" title="七、 总结"></a>七、 总结</h1><p>关于laravel的队列就是这些了，具体的细节部分，有大家去针对性的查看对应源码。这里对整体的逻辑做一个总结，如图:<br><img src="/images/queue.png" alt="queue"><br>具体payload在Redis中的流转过程如图：<br><img src="/images/queue-redis.jpg" alt="queue-redis"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20190701/laravel/auth.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20190701/laravel/auth.html" itemprop="url">laravel Auth源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-01T09:30:00+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ul>
<li><a href="#Auth模块">Auth模块</a><ul>
<li><a href="#AuthManager">AuthManager</a></li>
<li><a href="#Guard">Guard</a><ul>
<li><a href="#SessionGuard与TokenGuard">SessionGuard与TokenGuard</a></li>
</ul>
</li>
<li><a href="#UserProvider">UserProvider</a></li>
</ul>
</li>
<li><a href="#Auth与框架的关系">Auth与框架的关系</a><ul>
<li><a href="#AuthServiceProvider">AuthServiceProvider</a></li>
<li><a href="#路由解析">路由解析</a></li>
<li><a href="#路由中间件">路由中间件</a></li>
</ul>
</li>
</ul>
<p><code>Auth</code> 模块用于处理用户认证。在源码中，关于 <code>Auth</code> 模块，有两处命名空间：</p>
<ul>
<li><code>Illuminate\Auth</code>: <code>Auth</code> 模块核心代码。这部分的代码都是关于 <code>Auth</code> 模块的实现原理及逻辑。</li>
<li><code>Illuminate\Foundation\Auth</code>: <code>Auth</code> 模块应用功能。这部分是 <code>Auth</code> 模块在应用层的一些功能的实现。</li>
</ul>
<h2 id="Auth模块"><a href="#Auth模块" class="headerlink" title="Auth模块"></a>Auth模块</h2><p>三大组成部分</p>
<ul>
<li><code>AuthManager</code>: 认证管理器</li>
<li><code>Guard</code>: 认证器 <code>or</code> 看守器</li>
<li><code>UserProvider</code>: 用户提供者</li>
</ul>
<h3 id="AuthManager"><a href="#AuthManager" class="headerlink" title="AuthManager"></a>AuthManager</h3><p><code>AuthManager</code> 是用户认证模块功能的入口，是 <code>Auth</code> 类指代的实例。 <code>AuthManager</code> 的职责在于管理及扩展 <code>Guard</code> 与 <code>UserProvider</code>，这是他的“本职工作”，如果在使用过程中，我们不涉及对认证功能的扩展，一般不会用到这部分；<code>AuthManager</code> 的另一个职责，在于充当模块功能的入口，转发应用中对于 <code>Auth</code> 类的调用到 <code>Guard</code>，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Auth::user();</span><br><span class="line">Auth::check();</span><br><span class="line">Auth::login($user);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Auth::guard(&apos;web&apos;)-&gt;user();</span><br><span class="line">Auth::guard(&apos;web&apos;)-&gt;check();</span><br><span class="line">Auth::guard(&apos;web&apos;)-&gt;login($user);</span><br></pre></td></tr></table></figure>
<h3 id="Guard"><a href="#Guard" class="headerlink" title="Guard"></a>Guard</h3><p><code>Guard</code> 用于实现认证功能，在 <code>AuthManager</code> 实例化 <code>Guard</code> 时，会绑定一个 <code>UserProvider</code> 给 <code>Guard</code> ，用于后续提供用户实例。框架实现了 <code>SessionGuard</code> 及 <code>TokenGuard</code> ，分别用于使用 <code>session</code>，<code>token</code> 做用户认证的场景。<code>Guard</code> 的认证逻辑可以概括为：<code>Guard</code> 从上下文中获取登陆凭证，将登陆凭证传递给 <code>UserProvider</code>，查询出登陆用户的实例返回给 <code>Guard</code>。</p>
<h4 id="SessionGuard与TokenGuard"><a href="#SessionGuard与TokenGuard" class="headerlink" title="SessionGuard与TokenGuard"></a>SessionGuard与TokenGuard</h4><p><code>Session</code> 是非常常用的认证手段，框架实现的 <code>SessionGuard</code> 除了拥有认证功能外，还赋予了登陆与退出的功能。这里简单描述一下认证，登陆与退出的概念：</p>
<ul>
<li>登陆：客户端提交认证资料，经服务端验证成功后，生成登陆凭证，保存到相应位置，完成登陆。</li>
<li>认证：服务端检查登陆凭证是否存在及有效，有则完成认证，请求放行。</li>
<li>退出：服务端销毁登陆凭证，完成退出。</li>
</ul>
<p>只有认证才是 <code>Guard</code> 的职责，其他两个并不是 <code>Guard</code> 的职责。基于不同的认证实现，登陆与退出功能可能会交给其他模块完成。比如基于 <code>JWT</code> 的 <code>Token</code> 认证方式，其登陆凭证是保存在客户端的，服务端不保存，所以服务端无法主动销毁登陆凭证，也就没有退出功能。然而基于 <code>Session</code> 的认证方式，登陆凭证是保存在服务端的，所以基于 <code>Session</code> 认证的方式，<strong>可以</strong>提供退出功能。</p>
<p><code>SessionGuard</code> 实现的登陆功能，也就是文档中所指的“手动认证用户”部分。<code>SessionGuard</code> 提供 <code>attempt</code> 接口，用于用户登陆，同时提供了 <code>logout</code> 接口，实现了退出功能。<code>TokenGuard</code> 并没有这两个功能。</p>
<h3 id="UserProvider"><a href="#UserProvider" class="headerlink" title="UserProvider"></a>UserProvider</h3><p>用户提供者接收由Guard传递的用户标识，查询出用户实例并返回。框架实现了 <code>EloquentUserProvider</code> 与 <code>DatabaseUserProvider</code> ，分别需要在 <code>Auth</code> 配置中指定用户模型与用户表。大多数情况都是使用 <code>EloquentUserProvider</code>。</p>
<h2 id="Auth与框架的关系"><a href="#Auth与框架的关系" class="headerlink" title="Auth与框架的关系"></a>Auth与框架的关系</h2><p>要完整的了解 <code>Auth</code> 模块的认证过程，需要结合框架的其他模块及细节来解读。</p>
<h3 id="AuthServiceProvider"><a href="#AuthServiceProvider" class="headerlink" title="AuthServiceProvider"></a>AuthServiceProvider</h3><p>和其他模块一样，<code>Auth</code> 模块也是由服务提供者注册，在 <code>Laravel</code> 应用生命周期中，处于第二阶段（容器启动）的结束阶段，在这里第一次与 <code>Request</code> 产生互动：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illuminate\Auth\AuthServiceProvider</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerRequestRebindHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;rebinding(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app, $request)</span> </span>&#123;</span><br><span class="line">        $request-&gt;setUserResolver(<span class="function"><span class="keyword">function</span> <span class="params">($guard = null)</span> <span class="title">use</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> call_user_func($app[<span class="string">'auth'</span>]-&gt;userResolver(), $guard);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Auth</code>服务注册时，给 <code>request</code> 绑定了一个“重绑定”事件，该事件的目的何在？</p>
<p>首先需要知道，<code>request</code> 对象的实例化，是在容器启动之前，是一个比较早的阶段，可以说，在 <code>request</code> 对象第一次被实例化时，容器中基本还没有其他对象的存在，那么，如果在代码后续执行的过程中，需要丰富 <code>request</code> 对象，该怎么办呢？答案就是重绑定，在合适的时机，更新 <code>request</code> 对象之后，重新将 <code>request</code> 对象绑定到容器中。</p>
<p><code>Auth</code> 服务注册时，给 <code>request</code> 对象重绑定了一个事件，用于给 <code>request</code> 添加“用户解析”功能，当使用 <code>request</code> 的“用户解析”功能时，实际上会去找 <code>Guard</code> 要用户。然而，在服务注册阶段，<code>Guard</code> 表示我也还没实例化，你不能立刻来找我要用户，而是要“推迟”找我要用户的时间，所以，最终在这里绑定的是一个闭包，保存的是 <code>request</code> 解析用户的途径，在合适的时机，通过这一途径，即可找 <code>Guard</code> 要到用户，但这时机究竟是什么时候呢？这个时机，必须满足两个条件：</p>
<ul>
<li><code>request</code> 发生了重绑定</li>
<li><code>Guard</code> 认证用户结束</li>
</ul>
<h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><p>路由解析处于 <code>Laravel</code> 应用生命周期的的第三阶段（请求处理）。在第二阶段结束，第三阶段开始时，<code>request</code> 进行了重绑定：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illuminate\Foundation\Http\Kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// request 重绑定的发生过程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP kernel 捕获request，开始处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        $request-&gt;enableHttpMethodParameterOverride();</span><br><span class="line"></span><br><span class="line">        $response = <span class="keyword">$this</span>-&gt;sendRequestThroughRouter($request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;reportException($e);</span><br><span class="line"></span><br><span class="line">        $response = <span class="keyword">$this</span>-&gt;renderException($request, $e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;reportException($e = <span class="keyword">new</span> FatalThrowableError($e));</span><br><span class="line"></span><br><span class="line">        $response = <span class="keyword">$this</span>-&gt;renderException($request, $e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app[<span class="string">'events'</span>]-&gt;dispatch(</span><br><span class="line">        <span class="keyword">new</span> Events\RequestHandled($request, $response)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. HTTP kernel 发送request通过路由</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">sendRequestThroughRouter</span><span class="params">($request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里第一次对request经行绑定，但不会触发重绑定事件</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;instance(<span class="string">'request'</span>, $request);</span><br><span class="line">    <span class="comment">// 紧接着立刻清除已绑定的request对象</span></span><br><span class="line">    Facade::clearResolvedInstance(<span class="string">'request'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;bootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> Pipeline(<span class="keyword">$this</span>-&gt;app))</span><br><span class="line">        -&gt;send($request)</span><br><span class="line">        -&gt;through(<span class="keyword">$this</span>-&gt;app-&gt;shouldSkipMiddleware() ? [] : <span class="keyword">$this</span>-&gt;middleware)</span><br><span class="line">        -&gt;then(<span class="keyword">$this</span>-&gt;dispatchToRouter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. HTTP kernel 准备解析路由</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatchToRouter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// request 在这里重新被绑定，触发重绑定事件</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;instance(<span class="string">'request'</span>, $request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;router-&gt;dispatch($request);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>框架选择在此处对 <code>request</code> 进行重绑定，是因为，刚刚结束的第二阶段，已经完成了所有服务提供者的注册与启动，此时容器中已经存在所有的服务对象，通过服务对象来丰富 <code>request</code> 对象成为可能。</p>
<p>在 <code>request</code> 重新绑定之后，执行了这么一段代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illuminate\Auth\AuthServiceProvider</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;router-&gt;dispatch($request);</span><br></pre></td></tr></table></figure>
<p>这段代码的后文比较长，我简单概况一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配并命中路由 -&gt; 通过路由解析并实例化控制器对象 -&gt; 收集路由与控制器中定义的中间件 -&gt; 执行路由中间件 -&gt; 执行控制器方法</span><br></pre></td></tr></table></figure>
<h3 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h3><p>认证的行为，在中间件中触发。触发认证行为的中间件是<code>\Illuminate\Auth\Middleware\Authenticate::class</code>，在 <code>request</code> 通过该中间件时，<code>Guard</code> 检查 <code>request</code> 是否已通过认证，通过则放行，否则抛出<code>AuthenticationException</code>未认证异常。在通过认证之后，用户实例会保存在 <code>Guard</code> 对象中，后续所有找 <code>Guard</code> 要用户的行为，都可以得到相同的用户实例。至此，认证完成。</p>
<p>综上所述，用户的认证，发生在执行路由中间的过程中，在此之前，是无法通过 <code>Auth</code> 来获取认证用户的，需要特别注意的是，控制器的实例化过程，发生在路由中间件执行之前，所以无法在控制器的构造函数中获取用户的登陆状态。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.slpi1.com/20190506/laravel/progress.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="slpi1">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="slpi1">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/20190506/laravel/progress.html" itemprop="url">laravel 主流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T11:26:00+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: index.php入口</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">define_start_time=&gt;operation: 定义开始运行时间LARAVEL_START</span><br><span class="line">autoload=&gt;operation: composer自动加载</span><br><span class="line">load_app=&gt;condition: 框架载入</span><br><span class="line">instance_application=&gt;condition: 实例化容器</span><br><span class="line">Application::__construct</span><br><span class="line"></span><br><span class="line">app_base_binding=&gt;operation: 容器自绑定</span><br><span class="line">app_base_provider=&gt;operation: 容器基础provider注册</span><br><span class="line">Route/Log/Event</span><br><span class="line">app_base_alias=&gt;operation: 容器核心别名定义</span><br><span class="line"></span><br><span class="line">bind_base_kernel=&gt;operation: 单例绑定容器核心服务</span><br><span class="line">HttpKernel</span><br><span class="line">ConsoleKernel</span><br><span class="line">ExceptionsHandler</span><br><span class="line"></span><br><span class="line">make_http_kernel=&gt;operation: 实例化http处理器</span><br><span class="line">capture_http=&gt;operation: 捕获http请求</span><br><span class="line">kernel_handle_request=&gt;condition: http处理器处理请求</span><br><span class="line">bootstrap=&gt;condition: 容器启动</span><br><span class="line">bootstrap_app=&gt;operation: 加载环境变量配置</span><br><span class="line">加载配置文件</span><br><span class="line">注册异常handler</span><br><span class="line">注册Facades</span><br><span class="line">注册应用providers</span><br><span class="line">启动应用proveider</span><br><span class="line"></span><br><span class="line">common_middleware=&gt;condition: 全局中间件过滤</span><br><span class="line">dispatch_route=&gt;operation: 解析路由</span><br><span class="line">match_route=&gt;operation: 匹配路由</span><br><span class="line">instance_controller=&gt;operation: 实例化控制器</span><br><span class="line">route_middleware=&gt;condition: 路由中间件过滤</span><br><span class="line">call_action=&gt;operation: callAction引导执行控制器方法</span><br><span class="line">run_action=&gt;operation: 执行控制器</span><br><span class="line"></span><br><span class="line">common_middleware_item=&gt;operation: 全局中间件详情</span><br><span class="line">up&amp;down检查</span><br><span class="line">post包大小检查</span><br><span class="line">空格过滤</span><br><span class="line">空数据转化为null</span><br><span class="line">代理设置</span><br><span class="line"></span><br><span class="line">web_route_middleware_item=&gt;operation: 路由中间件详情</span><br><span class="line">cookie加密解密</span><br><span class="line">cookie设置</span><br><span class="line">start session</span><br><span class="line">Error闪存至session</span><br><span class="line">csrf验证</span><br><span class="line">路由模型绑定监听</span><br><span class="line"></span><br><span class="line">send_response=&gt;operation: 发送响应</span><br><span class="line">kernel_terminate=&gt;operation: http处理器运行后台任务</span><br><span class="line"></span><br><span class="line">st-&gt;define_start_time-&gt;autoload-&gt;load_app</span><br><span class="line">load_app(yes,right)-&gt;instance_application</span><br><span class="line">load_app(no,)-&gt;make_http_kernel-&gt;capture_http-&gt;kernel_handle_request</span><br><span class="line">instance_application(no)-&gt;bind_base_kernel(left)-&gt;make_http_kernel</span><br><span class="line">instance_application(yes, right)-&gt;app_base_binding-&gt;app_base_provider-&gt;app_base_alias(left)-&gt;bind_base_kernel</span><br><span class="line">kernel_handle_request(no)-&gt;send_response-&gt;kernel_terminate-&gt;e</span><br><span class="line">kernel_handle_request(yes, right)-&gt;bootstrap</span><br><span class="line">bootstrap(no)-&gt;common_middleware</span><br><span class="line">bootstrap(yes, right)-&gt;bootstrap_app</span><br><span class="line">common_middleware(no)-&gt;dispatch_route-&gt;match_route-&gt;instance_controller-&gt;route_middleware</span><br><span class="line">common_middleware(yes, right)-&gt;common_middleware_item</span><br><span class="line">route_middleware(no)-&gt;call_action-&gt;run_action(left)-&gt;send_response</span><br><span class="line">route_middleware(yes, right)-&gt;web_route_middleware_item</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="slpi1" />
          <p class="site-author-name" itemprop="name">slpi1</p>
           
              <p class="site-description motion-element" itemprop="description">PHP,Laravel,thinkPHP,javascript,css</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">slpi1</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
